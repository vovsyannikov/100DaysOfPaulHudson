import Foundation
//: [Контрольная точка 8](@previous) | [Содержание](Home) | [Контрольная точка 9](@next)
/*:
 # День 14: Опционалы

 ## Как работать с отсутствующими данными

 Swift любит быть предсказуемым. Если мы указываем тип данных у переменной или константы - он там гарантировано будет. Но бывают и случаи что нужных нам данных может не оказаться. Одним из способов работы с подобными ситуациями мы рассматривали на примере методов с ошибками `throwing functions`

 В Swift существует так же особая обёртка для типа данных: опциональный (`optional`). Она говорит, что значение может быть, а может и отсутствовать. Посмотрим пример:
 */

let opposites = ["Марио": "Варио", "Луиджи": "Валуиджи"]
let peachOpposite = opposites["Пич"]

/*:
 Что должно записаться в `peachOpposite`? Мы не указали значение по умолчанию, как делали это раньше в словарях, но и значения точно отсутствует. В данном случае мы получим опциональную строку `String?`. Для того, чтобы сказать компилятору и другим разработчикам, что значения может не быть, в конце любого типа ставится `?`. Дабы ответить на вопрос, что же запишется в `peachOpposite`, там будет особое значение: `nil`. Так в Swift обозначается отсутствие значение

 Каким образом эти самые опционалы влияют на наш код? Swift не позволит нам воспользоваться значением, которого не существует, а потому опционал надо "раскрыть", как коробку с секретом, чтобы узнать что внутри - реальное значение или пустота, `nil`. Чтобы открыть нашу коробку существует несколько способов, одним из самых распространённых является `if let`:
 */

if let marioOpposite = opposites["Марио"] {
	print("Противополжным персонажем Марио является \(marioOpposite)")
}

/*:
 Данная конструкция делает три вещи:

 1. Она смотрит внутрь опциональной контейнера, в данном случае наш словарь
 2. Если значение существует, тогда создаётся константа с этим значением
 3. Если константа с настоящим значением существует, значит условие выполняется и мы проваливаемся в тело условия, где мы можем обработать нашу новую константу (или переменную)

 Стоит ещё раз отметить, что опциональное значение отличается от реального
 */

var num1 = 1_000_000
var num2 = 0
var num3: Int? = nil

var str1 = "Hello"
var str2 = ""
var str3: String? = nil

var arr1 = [0]
var arr2 = [Int]()
var arr3: [Int]? = nil

/*:
 Во всех примерах выше 3 вариант является опциональным и он отличается от пустой строки, пустого массива и т.п. У нас есть реальное значение в `num2`, `str2`, `arr2`. Да, они представляют из себя пустое, но всё же значение. А вот 3 варинат говорит - тут нет значения. Тут в принципе пусто.

 В этом заключается главная фишка опционалов: они делают наш код безопасней. Если константа или переменная неопциональная - значит там гарантировано есть значение. Посмотрим на примере:
 */

func square(number: Int) -> Int {
	number * number
}

var number: Int? = nil
//print(square(number: number)) // Выдаёт ошибку, что мы пытаемся вызвать функцию с небезопасным параметром

if let unwrappedNumber = number {
	print(square(number: unwrappedNumber))
}

/*:
 Как и ожидалось, строка 62 не выполнилась, так как `number` не имеет значение - там пустота

 - Note:
 В Swift есть особая техника, которая практически является стандартом, называемая затенением (shadowing). Она позволяет нам не придумывать новые имена для временных констант и переменных, развёрнутых из опциональных значений. 

		if let number = number {
			print(square(number: number))
		}

	Выглядит это по началу странно, как какая-то квантовая хирургия, но на деле всё просто: мы задаём временную константу только на тело условия. Внутри будет использоваться развёрнутая версия, в то время как вне условия будет использоваться оригинал. Данная техника настолько популярна, что даже имеет сокращённый синтаксис:

			if let number {
				print(square(number: number))
			}

 ## Как раскрыть опционал с помощью `guard`

 Для раскрытия опционала используется конструкция `if let`, но это не единственный вариант. Очень часто появляется ситуация, в которой на вход в функцию поступает опциональный параметр, с которым предстоит работать до закрывающих тело функции фигурных скобок. Чтобы сразу откинуть не подходящее значение, мы можем использовать `guard … else` конструкцию. Для неё важно две вещи:

 - Условие прохождение
 - Блок, когда условие не прошло

 Рассмотрим на примере функции квадратного корня
 */

func squareRoot(of number: Double?) {
	if let unwrappedNumber = number {
		print("if let: \(sqrt(unwrappedNumber))")
	} else {
		print("Значение не найдено")
	}

	guard let unwrappedNumber = number else {
		print("Значение не найдено")
		return
	}

	print("guard let: \(sqrt(unwrappedNumber))")
}

var value: Double? = nil
squareRoot(of: value)

value = 169
squareRoot(of: value)

/*:
 Для `guard` блока всегда важно иметь вариант, когда условие ложно. При этом мы обязаны прекратить выполнение кода после. Если это функция, тогда обязательно необходимо сделать `return` или выкинуть ошибку через `throw` (если метод это поддерживает) для выхода, а если, например, цикл, тогда можно прекратить выполнение текущей итерации с помощью `continue` или полностью выйти из цикла с помощью `break`. Это не обязательно должны быть опционалы, можно просто проверить некое условие, но наиболее удобным применением `guard` конструкции для раннего выхода из функции если на пришли некорректные данные и раскрыть опционал, чтобы работать с ним как с обычным значением

 ---

 ## Как раскрыть опционал с помощью оператора нулевого замещения (`nil coalescing`)

 В это сложно поверить, но есть третий способ раскрыть опционал. Есть специальный оператор `??`, который позволит задать альтернативное значение, если в переменной или константе его нет. Посмотрим на примере
 */

let starships = [
	"Star Wars": "Тысячелетний Сокол",
	"Mass Effect": "Номандия SR-2",
	"StarTrek": "Энтерпайз"
]

let ship1 = starships["Простоквашино"] ?? "Не найден"
let ship2 = starships["Простоквашино", default: "Не найден"]

/*:
 Мы рассматривали словари и их способ взять указать значение по умолчанию. Но этот способ работает только со словарями. Для всех остальных доступен способ, как на строке 128. После присвоения или передачи в функцию значения опционала, надо поставить `??` и указать значение в том случае, когда данные отсутствуют. В таком случае наши константы будут обычными

 Рассмотрим пару примеров. Для того, чтобы получить случайный элемент из массива, существует метод `randomElement`. Он выдаёт опционал, так как массив сможет быть пуст, но мы можем указать значение по умолчанию:
 */

let movies = ["Легенда №17", "Майор Гром", "Вызов"]
let favorite = movies.randomElement() ?? "Не указан"

//: Можно обратиться к свойствам объекта и раскрыть их с помощью замещения

struct Book {
	let title: String
	let author: String?
}

let onegin = Book(title: "Евгений Онегин", author: nil)
let bookAuthor = onegin.author ?? "Не указан"
print(bookAuthor)

//: Мы можем так же приводить значения из одного типа в другой, но по умолчанию там возвращается опционал:

let input = ""
let realNumber = Int(input) ?? 0
/*:
 ---

 ## Как работать с цепочкой опциональных значений

 Мы можем создавать цепочки вызовов разных методов и полей у объектов. Если одно или несколько звеньев будут опциональными, тогда существует особый синтаксис для таких случаев. Звучит странно и сомнительно полезно, но давайте посмотрим пример:
 */

let team = ["Кирилл", "Даниил", "Сергей", "Борис"]
let chosenPlayer = team.randomElement()?.uppercased() ?? "Не выбран игрок"
print("Следующий на очереди: \(chosenPlayer)")

/*:
 Как мы видим, мы написали `?` после `randomElement()`. Таким образом мы говорим, что данное значение будет опциональным и всё, что идёт дальше по цепочке не будет выполнено, если на этом этапе будут отсутствовать данные. Если же значение не пустое, тогда выполнение продолжиться с ним, но в таком случае результат работы будет опциональным. В конце мы можем раскрыть цепочку как нам это удобно

 Посмотрим более экстремальный пример цепочки опционалов. Возьмём за основу структуру `Book` из раздела выше
 */

var book: Book? = nil
let author = book?.author?.first?.uppercased() ?? "A"
print(author)

/*:
 Здесь у нас целых 3 из 4 вызовов могут быть пустыми:

 - Если книга существует, смотрим на автора
 - Если автор существует, смотрим на первую букву
 - Если первая буква существует, сделать её заглавной

 Если хотя бы один из этих этапов выдаст `nil`, тогда выполнение перейдёт сразу в конец. Там мы указали значение по умолчанию, а значит присвоится именно оно. Если же мы не указываем оператор нулевого замещения, тогда сразу же будет присвоено `nil`

 ---

 ## Как обрабатывать ошибки в функциях с помощью опционалов

 При вызове функции, которая может кидаться ошибками, мы можем как прилежные разработчики правильно всё обработать с помощью `do … catch`, а можем просто сказать, что нам не важны ошибки и просто отдай `nil`, если что-то пошло не так. Есть ещё один, запретный способ раскрытия опционалов и обработки методов с ошибками. Он используется в самых исключительных случаях, когда разработчик уверен на 300%, что значение будет присутствовать в этот момент времени. Иначе - падение приложения

 Вот как это всё выглядит. У нас будет перечисление ошибок при обработке пользователя:
 */

enum UserError: Error {
	case badID
	case networkFailed
}

//: Есть функция, которая в рамках демонстрации всегда кидает ошибку

func getUser(id: Int) throws -> String {
	throw UserError.networkFailed
}

//: Теперь осталось обработать результат:

if let user = try? getUser(id: 24) {
	print("Найден пользователь \(user)")
}

/*:
 В данном случае нам попросту неважно, что там за ошибка вернулась из функции. Нам важно, вернулись ли данные. Если да, тогда выводим на экран данные. Иначе, просто работаем дальше. Для опциональных вызовов `try?`, можно использовать нулевое замещение, если поместить весь вызов в скобки. В таком случае, если будет выброшена ошибка или возвратилось опциональное значение, мы присвоим наш запасной вариант:
 */

let newUser = (try? getUser(id: 99)) ?? "Неизвестный"

/*:
 - Note:
 Если же разработчик полностью уверен, что значение не будет пустым, можно вместо `?` поставить `!`. В таком случае мы получим обычное значение или жёсткое падение приложения. Есть случаи, когда лучше сделать именно прямое открытие. Например, инициализация базы данных прошла с ошибкой и что-то не нашлось. Вместо того, чтобы в попыхах пытаться заставить приложение работать на костылях и чистой вере, лучше сразу устроить падение приложения для изучения в дальнейшем первопричины
 */

//: [Контрольная точка 8](@previous) | [Содержание](Home) | [Контрольная точка 9](@next)
