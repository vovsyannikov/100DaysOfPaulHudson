import Foundation
//: [Контрольная точка 1](@previous) | [Содержание](Home) | [День 4](@next)
/*:
 # День 3: Сложные типы данных (Часть 1)

 ## Как хранить данные в массивах

 В программировании для группирования набора информации массивы используются чаще других именно поэтому с ними проще всего работать. Как и с простыми данными, у массивов должен быть зафиксирован тип хранимых данных. Для создания нового массива, нужно через запятую указать все нужные нам данные и заключить их в квадратные скобки:
 */

var characters = ["Шрек", "Осёл", "Фиона", "Джефф"]
let numbers = [4, 8, 15, 16, 23, 42]
let temperatures = [25.3, 30, 28.2, 26.4]

/*:
 Для чтения данных из массива, надо взять имя константы или переменной и после, в квадратных скобках, указать индекс

 - Note:
 В массивах первый элемент всегда имеет индекс 0. Стоит считать индекс как смещение от первого элемента: чтобы получить первый элемент, мы должны сместиться на 0 элементов, чтобы получить второй - сместиться на 1 и т.д.
 */

characters[0]
numbers[1]
temperatures[2]

//: Для добавления нового элемента в массив, используется метод `append()`:

characters.append("Виталя")
characters.append("Григорий Лепс")
characters.append("Виталя")

/*:
 Строгая типизированность Swift так же следит за тем, чтобы в массив не попали данные другого типа или сложить два элемента разных массивов. Хоть массив (`Array`) является типом сам по себе, он является специализированным типом, который обязан знать, какие данные он должен хранить
 */

let firstBeatle = characters[0]
let firstNumber = numbers[0]
//let notAllowed = firstBeatle + firstNumber

/*:
 В строке 39 Xcode выдаст ошибку при выполнении, так как мы пытаемся сложить число и строку, что невозможно в строго типизированном языке

 Часто возникают моменты, когда исходных данных нет на момент создания переменной и заполнение произойдёт позже. Например, список песен в стриминговом сервисе, когда мы знаем, что получим, но самих данных с сервера мы ещё не получили
 */

var scores = Array<Int>()
scores.append(100)
scores.append(80)
scores.append(85)
print(scores[1])

/*:
 Разберём строку 47 поподробней. `var scores` это объявление переменной, `=` означает присвоение. Самое интересное начинается с `Array<Int>()`

1. `Array` - обозначает тип данных. Так Swift знает, что переменная `scores` будет массивом
2. `<Int>` - тип данных, заключённый в угловые скобки говорит о том, что будет храниться внутри массива. В данном случае - целые числа, но сюда можно вставить **любой другой** тип данных, включая другие массивы
3. `()` - круглые скобки в конце нужны для указания инициализации или создания массива. В данном случае скобки пустые и наш массив точно так же будет пустым, но это не единственный способ создания

 Массивы в Swift являются настолько популярным типом коллекций, что существует альтернативный способ создания:
 */

var movies = [String]()
movies.append("Шрек")
movies.append("Мои маленькие пони")
movies.append("Зелёный слоник")
movies.append("Титаник")

/*: 
 У массивов можно:

 - `count` - узнать размер
*/

movies.count

//: - `remove(at:)` - удалить элемент по индексу

movies.remove(at: 2)

//: - `removeLast()` - удалить последний элемент. В скобках можно указать количество элементов с конца, которые требуется удалить

movies.removeLast()

//: - `removeAll()` - очистить весь массив

movies.removeAll()

//: - `contains()` - узнать, содержится ли элемент в массиве

characters.contains("Билли Миллиган")

//: - `sorted()` - отсортировать массив

print(temperatures.sorted())

//: - `reversed()` - вернуть массив в обратном порядке. Однако результат не совсем тот, что ожидает неопытный разработчик: вместо массива вернётся тип `ReversedCollection`. Это сделано для оптимизации, чтобы не хранить в памяти потенциально огромные объёмы информации

let reversedNumbers = numbers.reversed()
print(reversedNumbers)
print(Array(reversedNumbers))

/*:
 Множество из рассмотренных выше функций доступны также и для строк, так как под капотом строки - это массив символов

 ---

 ## Как хранить и искать данные в словарях

 Массивы не всегда являются самым оптимальным методом хранения набора данных. В случаях, когда нам важно сохранить последовательность элементов или если у нас могут быть повторения, массивы - отличный выход. Но если нам необходимо брать конкретный элемент из коллекции, по индексам такое делать не удобно
 */

var employee = ["Тейлор Свифт", "Певица", "Нашвилль"]

print("Имя: \(employee[0])")
//employee.remove(at: 1)
print("Профессия: \(employee[1])")
print("Место проживания: \(employee[2])")

/*:
 В названии `employee` мы говорим, что это массив информации о сотруднике. Но что если в будущем мы захотим поменять порядок и на третьей позиции будет на местоположение, а пароль? Что если `employee[2]` вообще не заполнен? Swift выдаст ошибку при попытке получить элемент массива по несуществующему в нём индексу. В строке 116 мы удаляем элемент на второй позиции и теперь строка 117 напечатает "Профессия: Нашвилль", что является бредом, а на 118 строке - приложение вовсе завершится с ошибкой

 Для решение вышеуказанных проблем в Swift (и программировании в частности) существует другая структура данных: словарь `Dictionary`. В отличии от массивов, где элементы хранятся по индексам смещения, словари позволяют нам вручную указать индекс для каждого элемента. Пример выше можно переписать так:
 */

let employee2 = [
	"name": "Полина Гагарина",
	"job": "Певица",
	"location": "Москва"
]

/*: Описать словари можно так: это коллекция пар 'ключ: значение'. Чтобы прочитать данные из словаря достаточно вместо числового индекса как в массивах указать в квадратных скобках тот самый ключ */

print(employee2["name", default: "Не указано"])
print(employee2["job", default: "Не указано"])
print(employee2["location"])
print(employee2["manager"])
print(employee2["password", default: "Не указано"])

/*:
 - Note:
 В отличии от массивов, в котором при указании несуществующего индекса приложение просто упадёт. Вместо этого словари выдают предупреждение `Expression implicitly coerced from 'String?' to 'Any'` что означает значения по данному ключу может не быть. Поэтому результат в консоли будет слегка отличаться от ожидаемого. Это связано с понятием опционального значения (optional), которое будет рассмотрено позднее.

 На строках 134-138 рассмотрен способ указания значения по умолчанию, чтобы получить результат без предупреждений и в чистом виде, а так же что будет, если значения в словаре нет

 Но словари со строковыми ключами и значениями это лишь один пример. Можно указать любые из уже рассмотренных типов данных (кроме массивов) в качестве ключей и вообще любой тип данных для значений:
 */

let hasGraduated = [
	"Eric": false,
	"Maeve": true,
	"Otis": false
]

let olympics = [
	2014: "Сочи",
	2018: "Пхёнчхан",
	2022: "Пекин"
]

print(olympics[2014, default: "Не указано"])

/*: Как и массивы, словари очень популярный формат коллекции и для них существует несколько способов инициализации */

//var heights = Dictionary<String, Int>()
var heights = [String: Int]()

/*: Чтобы присвоить значение или перезаписать имеющееся в словарь (или массив), надо указать имя переменной и в квадратных скобках ключ или индекс, а затем через '=' указать желаемое значение */

heights["Яо Мин"] = 209
heights["Шакилл О'Нил"] = 216
heights["ЛеБрон Джеймс"] = 206
heights["Яо Мин"] = 229

/*:
 - Note:
 В строке 173 была исправлена ошибка в росте одного из баскетболистов. В таком случае не будет создана новая пара строка: число, а перезаписано имеющееся значение

 Так же для словарей доступен различный функционал, вроде `count`, `removeAll()` и многое другое

 ---

 ## Как использовать наборы `Set` для быстрого поиска

 В точности как и массивы, наборы используются для хранения групп данных. Главное отличие сетов в том, что они не хранят порядок элементов и в них не могут находится дубликаты. Создаются наборы схожим с массивами способом, но немного иначе:
 */

var actors = Set(["Дензел Вашингтон", "Том Круз", "Николас Кейдж"])
print(actors)

/*:
 Ключевое слово `Set` в строке 188 является обязательным, так как наборы - это строго специализированный набор данных и используется он реже остальных. Однако в круглых скобках присутствует массив исходных данных

 В строке 189 в консоли может вывестись наш список актёров в абсолютно любой последовательности, включая исходный

 Для добавления данных в набор мы не "добавляем" элементы (`append`), мы вставляем их (`insert`)
 */

actors.insert("Самуэль Л. Джексон")
print(actors)

/*:
 У неподготовленного человека возникает логичный вопрос: зачем нужны эти "упрощённые массивы" без удобного функционала порядка и дубликатов? Порой нужен именно такой набор. Например, для примера на строке 188 такой набор был сделан не случайно, так как не может быть двух Томов Крузов или 4-х Самуэлей Джексонов.

 - Note:
 В американской организации Гильдии киноактёров США запрещено иметь два одинаковых имени в списках участников. Так у актёра Майкла Китона, известного по роли Бэтмена из одноимённого фильма 1989г. и многим другим, настоящее имя Майкл Джон Дуглас. Когда Китон стал актёром во избежании путаницы с уже существующим и достаточно известным на тот момент времени Майклом Дугласом

 Что касается хранения порядка, то тут дело в производительности. В массивах каждый элемент хранится в памяти по смещению от исходного. И разница не в 2 секундах вместо 3. Поиск по набору происходит в считанные миллисекунды, в то время как для массива могут понадобиться минуты

		Для того, чтобы узнать, существует ли элемент в массиве из 100 записей, программа будет читать всю коллекцию до того, как он найдёт нужный нам элемент или пока не закончатся элементы. А что если таких элементов тысячи? Сотни тысяч? Миллионы?

 Для наборов существуют похожий функционал, что и для массивов, вроде `count` или `contains()`. Даже можно попросить отсортировать набор с помощью `sorted()` и он будет отсортирован по возрастанию элементов и выведен в формате массива

 ---

 ## Как создать и использовать перечисления `enum`

 Перечисления - очень мощный инструмент для обеспечения безопасности и простоты кода. Это набор именных значений, которые создаются под конкретную задачу

 Рассмотрим пример. Мы хотим хранить выбранный день недели. Для этого нужна переменная:
 */

var selectedDay = "Понедельник"
selectedDay = "Вторник"
selectedDay = "Июль" // Месяц?

/*: 
 В таком формате мы можем записать абсолютно любое значение в нашу переменную `selectedDay` что является логической ошибкой. В лучшем случае при работе в команде, коллега может отсмотреть код и указать на ошибку или код будет просто работать , хоть и некорректно отрабатывать

 Но что если мы введём что-то в таком духе:
 */

selectedDay = "пятница "

/*:
 Как мы уже выяснили в секции про строки, пробел в конце или маленькая буква в начале означает абсолютно другую строку. Плюс для хранения дня недели нам не нужно хранить целую строку, а достаточно какое-то символическое значение

 В этом нам и помогают перечисления. Это отдельный тип данных, у которого есть жёстко зафиксированный разработчиком набор значений. Таким образом мы избегаем необходимости сверять правильность введённых данных, учитывать разные факторы, вроде того же регистра у строк

 Перепишем пример на строках 223-225 и 233 через перечисление с днями недели:
 */

enum Weekday {
	case monday
	case tuesday
	case wednsday
	case thursday
	case friday
}

/*:
 Для объявления нового типа данных мы используем ключевые слова. Разберём строки 243-249 подробней:

 1. `enum` - ключевое слово обозначающее начало объявление перечисления
 2. `Weekday` - название перечисления, которое будет использоваться в дальнейшем
 3. Кавычки - начало и конец объявления нашего перечисления. Всё что находится внутри будет являться частью созданного типа
 4. `case …` - кейсы, которые представляют все возможные значения перечисления. Так же есть возможность прописать `case` единожды и указать все значения через запятую

 - Note:
 Обратите внимание на название перечисления: оно написано с большой буквы. Это часть конвенции не только на Swift, но и во многих других сферах программирования. Когда мы объявляем переменную или константу (или в случае с перечислениями - кейс), название пишется с маленькой буквы, а когда объявляем новый тип данных, вроде перечислений, классов или структур (о последних 2 позже), тогда первая буква заглавная. Такой формат даёт понять другим разработчикам, что они работают с каким-то объектом или же с просто переменной.

 Для создания нашей новой переменной для хранения текущего дня недели мы используем следующий формат:
 */

var day = Weekday.monday
day = Weekday.tuesday
//day = Weekday.july
day = .friday

/*:
 Теперь, когда мы сделали объявление переменной через перечисление, у нас не получится сделать орфографическую ошибку в названии или написать совершенно неподходящее под задачу значение (стр. 267 выдаст ошибку)

 Плюсом ко всему этому Xcode не подсказывает имеющиеся значения в перечислении, когда мы ставим точку, так ещё и постоянно прописывать `Weekday` при каждом присвоении значения нам не обязательно, поскольку мы это сделали в строчке 265. Xcode знает, что за тип данных лежит в `day` и позволяет сократить количество кода

 - Note:
Так же преимуществом перечислений является формат хранения. Вместо хранения целой строки для каждого кейса, под капотом там особое значение, которое гораздо эффективней любой строки
 */
//: [Контрольная точка 1](@previous) | [Содержание](Home) | [День 4](@next)
