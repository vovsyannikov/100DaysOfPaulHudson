import Foundation
//: [Контрольная точка 5](@previous) | [Содержание](Home) | [День 11](@next)
/*:
 # День 10: Структуры (Часть 1)

 После замыканий можно немного расслабить мозг и взглянуть на что-то гораздо проще, но не менее важное. МОжет быть даже важней, так как Swift практически основан на структурах. Основные типы данных, такие как `String`, `Bool`, `Int` и другие под капотом являются структурой. Даже графический интерфейс в SwiftUI построен на них. Так что же за зверь такой эта ваша структура?

 Структура - это набор взаимосвязанных данных и методов, объединённых общим контейнером. Если по русски, то если представить, как бы мы описали музыкальный альбом, то у него могут быть имя, автор и год выпуска, а так же возможность вывести информацию о себе

 В данном случае у нас будет структура `Album` с большой буквы, так как мы объявляем тип, наравне с `Int` или `String`. У любой структуры есть набор полей или свойств (данных) и методов (функций)

 Рассмотрим пример:
*/

struct Album {
	let title: String
	let artist: String
	let year: Int

	func printSummary() {
		print("\(title) - \(artist) (\(year))")
	}
}

/*:
 Теперь когда мы описали как должен выглядеть наш альбом, так же называемый иногда прототипом, мы можем создать пару экземпляров:
 */

let red = Album(title: "Red", artist: "Тейлор Свифт", year: 2012)
let breath = Album(title: "Вдох", artist: "Полина Гагарина", year: 2016)

/*: 
 Обратите внимание на формат создания наших альбомов. Он выглядит, как вызов функции. Здесь мы указываем имя объекта, который хотим создать, а в скобках указываем все свойства, которые нужны для его существования, словно параметры функции. Данный процесс называется инциализацией объекта. Для полного понимания, данная строка должна выглядеть так: `let red = Album.init(title: "Red", artist: "Тейлор Свифт", year: 2012)`. У любой структуры или класса (о них позже) существует специальная функция - инициализатор (от слова initializer - исходный). Swift подслащает нам жизнь, позволяя убрать `.init` при создании объекта. Стоит отметить, что мы не указывали подобной функции, когда создавали саму структуру `Album`. Swift делает это за нас для структур

 C реальными альбомами, мы можем использовать их данные через точку:
 */

red.artist
breath.title

red.printSummary()
breath.printSummary()

/*:
 Когда мы вызываем `red.artist` или `breath.printSummary()`, Swift осознаёт, что мы хотим получить данные из этих конкретных экземпляров

 Дела немного меняются, когда мы хотим изменять значения внутри структур. Взглянем на пример сотрудника, который может брать дни отпуска:
 */

struct Employee {
	let name: String
	var vacationDaysRemaining: Int = 30

	mutating func takeVacation(days: Int) {
		if vacationDaysRemaining > days {
			vacationDaysRemaining -= days
			print("\(name): берёт отпуск")
			print("\(name): остаётся дней для отпуска: \(vacationDaysRemaining)")
		} else {
			print("\(name): не возможно отправить в отпуск на \(days) дней")
		}
	}
}

/*:
 Поскольку структура изначально считает, что данные внутри не будут модифицироваться, просто так позволить функциям вносить изменения нельзя. Для того чтобы сказать Swift (и другим разработчикам), что метод будет менять саму структуру (потому что при изменении данных, структура будет создана заново), надо указать ключевое слово `mutating` перед объявлением метода. В противном случае Xcode будет ругаться на строку 56, в которой мы меняем значение переменной `vacationDaysRemaining`
 */

var employee1 = Employee(name: "Сотрудник 1")
let employee2 = Employee(name: "Сотрудник 2", vacationDaysRemaining: 14)

employee1.takeVacation(days: 10)
//employee2.takeVacation(days: 14) // Будет ошибка, так как `employee2` является константой

/*:
 Для структуры сотрудника мы указали исходное значение для свойства `vacationDaysRemaining`. Поскольку Swift генерирует для нас функцию инициализатора, он так же может указать там параметры с исходными данными. Потому у `employee1` будет 30 дней отпуска, без необходимости указывать это при создании экземпляра, а `employee2` мы дали только 14 дней. Однако, поскольку свойство `name` является константой, его указать при инициализации мы обязаны

 ---

 ## Как динамически вычислять данные

 У объектов могут быть два разных типа свойств: хранимые и вычисляемые

 Первые мы уже рассмотрели - это обычные константы и переменные. А что такое вычисляемые поля? Это смесь хранимых данных и некоего функционала, который будет вызывать каждый раз при чтении такого свойства

 Рассмотрим пример нашего сотрудника. Когда тот берёт отпуск, мы теряем информацию о том, сколько дней было у него изначально. Что если нам необходимо знать точный размер отпуска? Создадим новую структуру `StaffMember`, но с учётом данной корректировки
 */

struct StaffMember {
	let name: String
	var vacationAllocated: Int = 30
	var vacationTaken: Int = 0

	var vacationRemaining: Int {
		vacationAllocated - vacationTaken
	}
}

/*:
 Теперь наша структура знает, сколько дней изначально у нашего сотрудника в переменной `vacationAllocated`. Каждый раз, когда мы будем брать отпуск мы будем добавлять дни в переменную `vacationTaken`

 Вот здесь и появляется наше вычисляемое свойство `vacationRemaining`. Синтаксически оно очень схоже с замыканием с двумя важными отличиями:

 1. Мы не присваиваем это замыкание в переменную, а напрямую говорим, что должно произойти при вызове данного поля
 2. При вызове, нам не надо ставить скобки, так как это обычная переменная

 Вычисляемые поля решают главную проблему вычислений. В нашем случае, если бы `vacationRemaining` была бы обычной переменной, нам пришлось бы учитывать этот факт при отправке сотрудника в отпуск и уменьшать её одновременно с увеличением `vacationTaken`. Вместо этого, мы просто будем считать на лету наше значение и оно всегда будет правильным. В довес к этому мы уменьшаем размер структуры, так как нам не надо хранить ещё одно число

 - Note:
 Мы уже сталкивались с подобными вычисляемыми полями, когда мы рассматривали `count` у строк и коллекций. Теперь должно быть понятно, почему для данного поля не нужны были скобки, а для других действий - нужны
 */

var staffMember = StaffMember(name: "Сотрудник 3", vacationAllocated: 14)
staffMember.vacationTaken += 4
print(staffMember.vacationRemaining)
staffMember.vacationTaken += 5
print(staffMember.vacationRemaining)

/*:
 При том что мы пометили `vacationRemaining` как `var`, она не поддерживает записи, потому что Swift не знает, как произвести запись в данную "переменную". Должно ли значение `vacationAllocated` изменяться или `vacationTaken`?

 Вычисляемые поля и в этот раз нам смогут помочь. Представим, что в нашей ситуации увеличение/уменьшение оставшихся дней отпуска означает изменение выделенных дней, а не потраченных. Мы посмотрели, как вычисляемые поля могут получать значение, но они так же могут и записывать. Для этого используются `getter` и `setter` соответственно. Если вычисляемое поле должно быть только читаемым, тогда подойдёт формат выше. Однако при объявлении `setter` мы должны обозначить и `getter` для нашего свойства.

 Наша структура `vacationRemaining` после изменений будет выглядеть так:

	var vacationRemaining: Int {
		get { vacationAllocated - vacationTaken }
		set { vacationAllocated = vacationTaken + newValue }
	}

 Как мы видим блок, в котором мы читаем значение, обозначается ключевым словом `get`. В блоке же `set` мы записываем новое значение. Особого внимания заслуживает `newValue`. Это такое же сгенерированное имя для параметра, как `$0`, `$1` и т.д. в замыканиях или `error` в блоке `catch`, когда мы ловим ошибку из функции.

 - Note:
 Для блока `set` можно назначить другое имя переменной, нежели `newValue`, но делается это по особенному. Для наглядности приведу пример на основе строки 134: `set(days) { vacationAllocated = vacationTaken + days }`. Используется данная особенность языка редко, но знать о ней полезно

 ---

 ## Как выполнять действия на изменения свойств

 Для того, чтобы выполнить какой-то код при изменении свойства объекта, существуют наблюдатели свойств (property observers). Существует два вида:

 - `willSet` - будет вызван **ДО** изменения значения
 - `didSet` - будет вызван **ПОСЛЕ** изменения значения

 Рассмотрим простейший пример. У нас есть структура Игры, которая хранит текущий счёт. Мы хотим вывести в консоль текущий счёт после каждого изменения. Выглядит это так:
 */

struct Game {
	var score: Int = 0
}

var game = Game()
game.score += 10
print("Счёт: \(game.score)")
game.score -= 4
print("Счё: \(game.score)")
game.score += 1

/*:
 На первый взгляд всё выглядит отлично, за исключением последнего изменения счёта - я забыл вывести новый счёт в консоль. Это баг, который необходимо исправить. Мало того, что мы не выводим счёт при каждом изменении, так ещё и в строке 156 имеется опечатка

 Все эти проблемы решают наблюдатели свойств. То есть наша переменная `score` будет выглядеть так:

	var score: Int = 0 {
		didSet { print("Счёт: \(score)") }
	}

 Рассмотрим слегка другой пример использования обоих наблюдателей
 */

struct App {
	var contacts: [String] = [] {
		willSet { // Передаёт будущее значение в виде `newValue`
			print("Обновляем контакты: \(contacts) -> \(newValue)")
		}

		didSet { // Передаёт прошлое значение в виде `oldValue`
			print("Количество контактов: \(oldValue.count) -> \(contacts.count)")
		}
	}
}

var app = App()
app.contacts.append("Елена Прекрасная")
app.contacts.append("Василиса Премудрая")
app.contacts.append("Снегурочка")
app.contacts = []

/*:
 Теперь при каждом изменении сначала будет вызываться `willSet`, затем выставится новое значение, а после всего этого `didSet`. На практике чаще используется `didSet`, однако у `willSet` так же есть своя область применения, например, если мы изменяем какое-то значение и мы хотим предупредить наш UI о готовящихся изменений для синхронизации анимаций

 - Note:
 Не стоит нагружать наблюдателей интенсивной работой, вроде вызовов в базу данных или обращения к серверу. Они пригодны для лёгкого обновления переменных внутри самого объекта или для вывода в консоль или отдельный файл логов сообщений, чтобы в дальнейшем было проще отлаживать работу приложения

 ---

 ## Как создать свой инициализатор

 Мы уже видели, что Swift генерирует нам инициализаторы для структур. Такой инициализатор называют элементным или инициализатор по элементам (memberwise initializer) В свою очередь разработчик может сделать свою реализацию. Есть лишь два правила:

 1. Имя инициализатора всегда `init`
 2. К концу инициализатора все объявленные свойства обязаны иметь значение

 Посмотрим, как выглядит инициализатор, сгенерированный Swift, но написанный вручную и собственный
 */

struct Player {
	let name: String
	let number: Int

	init(name: String, number: Int) {
		self.name = name
		self.number = number
	}

	init(named name: String) {
		self.name = name
		number = Int.random(in: 1...99)
	}
}

let dzyuba = Player(name: "А. Дзюба", number: 22)
let akinfeev = Player(named: "И. Акинфеев")

/*:
 Как мы видим у нас есть несколько инициализаторов. Как выясняется мы можем их вводить до бесконечности. Нам не нужно указывать ключевого слова `func` даже при всём при том, что по сути это и есть функция; нам не нужно указывать возвращаемое значение, потому что мы не можем вернуть из создания структуры `Player` целое число

 Поскольку имена параметров в первом инициализаторе, который точь в точь повторяет автоматическую реализацию Swift, совпадают с таковыми у структуры, нам надо их различать. Для этого мы используем `self` как указание того, что мы говорим именно о полях объекта, а не о параметрах инициализатора или любой другой функции.

 - Note:
 Если мы создаём инициализатор таким способом, Swift отключает генерацию этого метода. Таким образом мы говорим, что у нас есть особая логика создания объекта и автоматический инициализатор может сломать поведение всей программы. Существует способ иметь собственные инициализаторы **И** автоматически сгенерированный, но об этом позже
 */
//: [Контрольная точка 5](@previous) | [Содержание](Home) | [День 11](@next)
