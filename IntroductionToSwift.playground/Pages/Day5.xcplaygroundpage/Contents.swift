import Foundation
//: [Контрольная точка 2](@previous) | [Содержание](Home) | [День 6](@next)
/*:
 # День 5: Условия

 ## Как проверить условие истинно или ложно

 Программам очень часто приходится делать выбор:
  - Если студент сдал экзамен, вывести сообщение с поздравлением
  - Если пользователь ввёл новое имя и оно должно стоять до имени друга, сначала поместить в массив имя друга
  - Если добавление числа в массив расширит его до 3 элементов, убрать самое старое значение
  - Если попросить пользователя ввести имя и он оставил поле пустым, присвоить ему имя "Неизвестный"

 В Swift эти и многие подобные им условия описываются следующим образом:
 */

let score = 85

if score > 80 {
	print("Молодец!")
}

/*:
 Разберём строки 20-22:
 1. `if` - ключевое слово начала условия
 2. `score > 80` - само условие.
 3. `{ }` (Фигурные скобки) - означают начало и конец блока условия. Если условие истинно, тогда код внутри скобок будет выполнен, а иначе - пропущен. Количество строк ограничено

 Условием мы взяли сравнение нашего текущего балла с минимальным проходным. Для этого использовался арифметический знак больше `>`, однако поддерживаются и многие другие операторы сравнения и логические операторы:
 */

let speed = 88
let age = 18

if speed >= 88 { // `speed` больше или равно 88
	print("Дороги? Там, куда мы едем, они не нужны")
}

if score < 50 { // `score` меньше 50
	print("Вы не прошли экзамен")
}

if age <= 17 { // `age` меньше или равно 17
	print("Вы не можете голосовать")
}

//: Мы можем сравнивать не только числа, но и строки по алфавитному порядку

let myName = "Admin"
let friendName = "User"

if myName < friendName {
	print("\(myName) vs. \(friendName)")
}

if myName > friendName {
	print("\(friendName) vs. \(myName)")
}

//: В качестве условий можно брать различные свойства массивов:

var numbers = [1, 2, 3]
numbers.append(4)

if numbers.count > 3 {
	numbers.remove(at: 0)
}

print(numbers)

/*: 
 Для условий подходят также логические операторы:

- `==` - "Равно"
- `!=` - "Не равно"
 */

let country = "Канада"

if country == "Россия" {
	print("Здарова")
}

let name = "Филипп Киркоров"

if name != "Неизвестный" {
	print("Приветствую, \(name)")
}

var username = "progamer2014"

if username == "" {
	username = "Anonymous"
}

print("Добро пожаловать, \(username)")

/*:
 - Note:
 Для строки 93 есть оптимизация. Поскольку сравнивать 2 строки всегда трудоёмкий процесс, стоит избегать подобного сравнения. Можно использовать сравнения через количество символов `count`, однако Swift начнёт считать каждый символ один за одним, а некоторые строки могут быть особо длинными (эмодзи могут занимать несколько позиций) `if username.count == 0 {…}`. В моменты, когда нам нужно узнать пуста ли строка, лучше всего использовать встроенную переменную `isEmpty`. В таком случае можно даже опустить сравнение с `true` и код будет читаться как чистый английский язык
 */

if username.isEmpty {
	username = "Anonymous"
}

/*:
 ## Как проверить несколько условий

 Для того, чтобы проверить несколько условий можно использовать следующую конструкцию:

 ```Swift
 if age >= 18 {
	print("Вы можете голосовать")
 }

 if age < 18 {
	print("Подрастите")
 }

 ```

 В данном случае такой код заставляет нашу программу делать две проверки, когда они являются взаимоисключающими. Проще будет проверить одно условие и выполнить код, если оно истинно, либо выполнить другие операции
 */

if age >= 18 {
	print("Вы можете голосовать")
} else {
	print("Подрастите")
}

/*: Если же необходимо проверить несколько условий с разными проверками, это можно сделать следующим образом:

	if a {
		// Выполняется если условие `а` истинно
	} else if b {
		// Выполняется если условие `a` ложно **И** условие `b` истинно
	} else {
		// Выполняется если все предыдущие условия ложны
	}

 Так же можно объединить несколько условий в одну строку с помощью логически операторов `&&` и `||`. В первом случае результат будет истинным если **ОБЕ** стороны истинны, а второе - если **ХОТЯ БЫ** одно из условий истинно
 */

let temp = 25

if temp > 20 && temp < 30 {
	print("Хороший день для прогулки")
}

let userAge = 14
let hasParentalConsent = true

if age >= 18 || hasParentalConsent {
	print("Можно купить игру")
}

/*:
 Для наглядности приведём пример посерьёзней, где будут применены почти все рассмотренные опции

 У нас есть перечисление всех видов транспорта, которые поддерживаются приложением. И в зависимости от выбранного пользователем способа, надо вывести особое сообщение
 */

enum TransportOption {
	case airplane, helicopter
	case car
	case bicycle, walking
}

let transport = TransportOption.airplane
if transport == .airplane || transport == .helicopter {
	print("Полетели!")
} else if transport == .bicycle {
	print("Надеюсь там будут велосипедные дорожки…")
} else if transport == .car {
	print("Опять попадём в пробку!")
} else {
	print("Надеюсь дождя не будет…")
}

/*:
 ## Как использовать `switch` для проверки нескольких условий

 Для проверки нескольких условий можно использовать `if else` условия для всех возможных вариантов исхода
 */

enum Weather {
	case sunny
	case rainy
	case windy
	case snowy
	case unknown
}

let forecast = Weather.sunny

if forecast == .sunny {
	print("Ожидается хороший денёк")
} else if forecast == .rainy {
	print("Ожидается хороший денёк")
} else if forecast == .windy {
	print("Одевайся теплее")
} else if forecast == .rainy {
	print("В школу не идём")
} else {
	print("Генератор прогноза погоды сломался!")
}

/*:
 С кодом на строчках 198-208 есть несколько проблем:

 1. Нам постоянно приходится писать `forecast` хотя в условии ничего другого не проверяется
 2. В строках 200 и 204 ошибочно проверяется одно и то же условие
 3. Из-за проблемы №2 не проверяется прогноз `.snowy`, так что часть функционала приложения отсутствует

 Для подобных случаев есть удобный функционал в виде `switch` и вот как он выглядит:
 */

switch forecast {
case .sunny:
	print("Ожидается хороший денёк")
case .rainy:
	print("Ожидается хороший денёк")
case .windy:
	print("Одевайся теплее")
case .snowy:
	print("В школу не идём")
case .unknown:
	print("Генератор прогноза погоды сломался!")
}

/*:
Разберём строки 220-231:

 1. `switch forecast` - означает начало `switch` проверки по значениям `forecast`
 2. `case .<значение>:` - для каждого из возможных значений существует строчка `case`. Если значение `forecast` совпадает с кейсом, тогда выполняется условие после двоеточия

 `switch` позволяет выбрать значение для проверки и не прописывать его для каждого возможного варианта.

 Так же эта конструкция исчерпывающая, то есть в ней разработчик **обязан** перечислить все возможные значения. Если мы попробуем проверить дважды условие `.rainy` мы получим 2 ошибки:

- Мы не проверяем `.snowy`
- Мы проверяем `.rainy` дважды

 Если в дальнейшем мы скорректируем `Weather`, тогда Xcode укажет ошибкой в данном `switch` что нам надо обновить и проверку

 У `switch` в Swift есть две отличительных особенности от некоторых других языков, как например С++:

 1. Исчерпывающая натура, при которой мы **ОБЯЗАНЫ** указать действие на все возможные варианты исхода
 2. При выполнении одного условия, следующие за ним  **НЕ БУДУТ** выполнены автоматически. Что менее логично, нежели поведение в Swift

		Если `forecast` имеет значение `.windy`, то в С++ в консоль вывелось бы 3 строчки для кейсов `.windy`, `.snowy` и `.unknown`

 Однако исчерпывающая натура `switch` иногда играет злую шутку. Например, как перечислить все варианты для числовой переменной? Или для текста? Прописывать миллиарды разных кейсов никто не будет да и за такое надо бить палками. Чтобы этим не заниматься, в Swift есть особый кейс `default`, который равнозначен `else`, то есть выполнится в случае, если ни один из предыдущих вариантов не подошёл
 */

let place = "Тридевятое царство"

switch place {
case "Деревня Простоквашино":
	print("Вы Дядя Фёдор")
case "Лукоморье":
	print("Вы Кот Учёный")
default:
	print("Вы кто?")
}

/*:
 - Note:
 Обратите внимание, что `default` находится в самом низу списка не случайно. Если представить, что кейс `default` равнозначен `else`, то это значит окончание действия блока `switch` и ничего после уже быть не может.

	Стоит отметить, что Swift не будет проходить по каждому условию как с цепочкой `if elseif`, а сразу перейдёт к нужному выбору.

 Для того, чтобы вернуть поведение из С++, существует ключевое слово `fallthrough`, которое позволяет "провалиться" к выполнению следующего блока кода без проверки условия. Данную команду следует прописывать в каждом условии, в котором необходимо перейти дальше по цепочке действий. Такое поведение редко используется в реальных проектах, но иметь такую возможность всегда приятно, чем не иметь вовсе и пытаться придумывать альтернативные способы решения проблемы

 Разберём пример обоснованного использования `fallthrough` в `swtich`. Есть знаменитая рождественская песня 12 дней рождества, в которой с каждым днём исполнителю дарят всё больше и больше подарков
 */

let day = 5
print("My true love gave to me…")

switch day {
case 5:
	print("5 golder rings")
	fallthrough
case 4:
	print("4 calling birds")
	fallthrough
case 3:
	print("3 French hens")
	fallthrough
case 2:
	print("2 turtle doves")
	fallthrough
default:
	print("A partridge in a pear tree")
}

/*:
 ## Как использовать тернарый оператор для быстрых проверок

 Существует ещё один способ проверки условий с использованием тернарного оператора. Это понятие чуждо для многих, однако объяснить его легко, а понять - не просто

 В программировании и многих других областях используется 3 типа операторов, двумя из которых все когда либо встречались в школе:

 1. Унарный("Uno" - один) - Такие операторы работают с одним "операндом". К данному типу относятся, например, арифметический минус перед числом, чтобы сделать его отрицательным или логический оператор `!`, который меняет булевую переменную на противоположную
 2. Бинарный("Binary" - двоичный) - Эти операторы принимают два операнд для работы с ним. Это классические арифметические операции сложения, вычитания и т.д., логические операторы сравнения (`<`, `>` `==`, и т.д.), операторы "И", "ИЛИ" и т.п.
 3. Тернарный("Tertiary" - третичный) - оператор, который принимает 3 операнд для своих операций. На данный момент используется лишь один подобный оператор и преимущественно в программировании

 Если бы не широкое применение тернарного оператора для создания приложений на SwiftUI, данная часть курса могла бы не существовать, однако без него будет немного сложней работать. Структура выглядит следующим образом:

		<условие> ? <истина> : <ложь>

 Можно использовать мнемоническое устройство для упрощения запоминания: ПИЛ

 - Задать вопрос "Правильно?"
 - Если ответ да, тогда истина
 - Если ответ нет, тогда ложь

 Приведём несколько примеров
 */

let voterAge = 18
let canVoteAnswer = age >= 18 ? "Да" : "Нет"

let names = ["Красная Шапочка", "Волк", "Бабушка", "Охотник"]
let characterCountDescription = names.isEmpty ? "Никого" : "Персонажей: \(names.count)"

enum Theme {
	case light
	case dark
}

let theme = Theme.dark
let background = (theme == .dark) ? "Чёрный" : "Белый"

/*:
 Главная причина существования тернарного оператора заключается в том, что их можно использовать как выражение для присвоения значений, в то время как `if else` или `switch` нельзя, так как это операции

 Так же немаловажным фактором является краткость. Если сравнить реализацию проверки в строчке 325 с такой же, построенной через `if else` мы получим следующий кусок кода:

		let voterAge = 18
		let canVoteAnswer: String

		if age >= 18 {
			canVoteAnswer = "Да"
		} else {
			canVoteAnswer = "Нет"
		}

 Мы превратили удобный код из двух строчек в код из 7, не говоря уже о том, что такой формат больше пригоден для функций (которые будут рассмотрены позже), что ещё больше увеличит файл. SwiftUI обожает тернарные операторы и если каждый раз выносить огромные блоки кода в отдельные функции, то размеры окон будут непостижимыми
 */
//: [Контрольная точка 2](@previous) | [Содержание](Home) | [День 6](@next)
