import Foundation
//: [День 5](@previous) | [Содержание](Home) | [Контрольная точка 3](@next)
/*:
 # День 6: Циклы

 ## Как использовать циклы для повторения работы

 Компьютеры отлично подходят для выполнения повторяющихся действий и в Swift позволяет с лёгкостью повторить некое действие фиксированное количество раз или сделать что-то с каждым элементом коллекции

 Начнём с примера:
*/

let platforms = ["iOS", "macOS", "tvOS", "watchOS"]

for os in platforms {
	print("Swift отлично работает на \(os)")
}

/*:
 Давайте разбираться:

 1. `for` - Ключевое слово для объявления цикла
 2. 'os in platforms` - Условие цикла. Данную строчку можно трактовать как "для каждого элемента в `platforms`, создать константу `os` и поместить в тело цикла"
 3. `{ }` - Тело цикла, в котором прописываются действия с каждым поступающим из условия элементом

 Немного про `os`. Название может быть любым и эта константа будет использоваться исключительно внутри тела цикла. Данное поведение называется полем видимости. Поскольку `os` объявляется в условии цикла, оно может быть использовано **исключительно** в теле данного цикла и нигде иначе

 - Note:
 Стоит отметить, что `os` является константой и полное условие цикла должно выглядеть так: `for let os in platforms {…}`. Соответственно манипулирование данной константой будет ограничено. Если мы хотим менять данные, тогда можно вручную прописать `for var os in platforms`. В таком случае мы сможем менять только саму переменную `os`, не данные в массиве `platforms`

 Однако, порой необходимо провести операции с данными не по коллекции, а определённое количество раз. Для этого используются диапазоны. В качестве примера возьмём таблицу минут аналоговых часов:
 */

for i in 1...12 {
	print("5 x \(i) = \(5 * i)")
}

/*:
 `1...12` означает закрытый диапазон от 1 по 12 включительно с шагом в 1. Для этого в Swift есть специальный тип который так и называется `ClosedRange`. Таким образом `i` будет сначала 1, затем 2 и т.д.

 - Note:
 Название константы цикла `i` является конвенцией программистов для обозначения счётчика. Если необходимо считать второй цикл, в нём будет использоваться `j`. Однако, это лишь предложение. Например, для построения матриц или таблиц можно использовать `row` для строк и `col` для столбцов

 Выведем таблицу умножения в консоль с помощью вложенных циклов
 */

for i in 1...9 {
	print("Таблица умножения для \(i)")

	for j in 1...9 {
		print("    \(i) x \(j) = \(i * j)")
	}

	print()
}

/*:
 - Note:
 В строке 55 присутствует пустой `print()`. Таким образом в консоли будет сделан перенос строки для визуального разделения блоков

 Если существует закрытый диапазон `ClosedRange`, значит есть и открытый, который именуется в Swift просто `Range`. Чтобы продемонстрировать разницу создадим два цикла используя оба диапазона
 */

var closedRange = "Закрытый диапазон:"
for i in 1...5 {
	closedRange.append(" \(i)")
}

var openRange = "Открытый диапазон:"
for i in 1..<5 {
	openRange.append(" \(i)")
}

print(closedRange) // Закрытый диапазон: 1 2 3 4 5
print(openRange) // Открытый диапазон: 1 2 3 4

/*:
 Открытый диапазон `1..<5` можно интерпретировать как числа от 1 строго до 5 или до ближайшего числа меньше 5, то есть 4. Разница во фразах от 1 *по* 5 и с 1 *до* 5 кардинальная и означает разницу между закрытым и открытым диапазоном

 Для понимания необходимости двух разны форматов диапазонов, стоит привести наглядный пример. Мы уже видели как строить таблицы умножения с помощью закрытых диапазонов, но открытые не менее важные для таких задач как прохождения по индексам массива, где первый элемент имеет индекс 0, а последний будет на 1 меньше общего количества
 */

let groceries = ["Бананы", "Яблоки", "Груши", "Персики", "Сливы", "Клубника", "Хлеб"]
var visibleGroceries = [String]()
for i in 0 ..< groceries.count {
	if i < 3 {
		visibleGroceries.append(groceries[i])
	}
}

print("Надо купить: \(visibleGroceries)")

/*:
 - Note:
 Данный тип итерации полезен, если нам нужно вывести не все элементы коллекции, а лишь определённое их количество как в примере выше. Такое полезно делать для виджетов, у которых ограниченное место для вывода информации

 Может сложиться логичный вопрос: а что если мне не важно знать, какое сейчас значение переменной цикла? Для этого можно просто не использовать её в теле цикла, однако тогда Xcode выведет предупреждение о неиспользованной переменной. Есть способ лучше. Вместо названия переменной цикла, можно поставить нижнее подчёркивание `_`. Вот пример на основе слов из песни Тейлор Свифт 'Shake It Off' написанной на Swift
 */

var lyric = "Haters gonna"
for _ in 1...5 {
	lyric += " hate"
}

print(lyric)

/*:
 ## Как использовать цикл `while` для повторяющейся работы

 Цикл `while` - это условынй цикл. То есть его тело будет вызывать до тех пор, пока заданное условие не станет ложным. В отличии от циклов `for`, которые является циклами с счётчиками и их условие для прерывания - достижения счётчиком конечного числа, а значит количество повторений известно заранее и зафиксировано в самом начале

 - Note:
 Циклы `while` встречаются довольно редко из-за их специфики работы, однако это не отменяет их необходимости в некоторых сценариях. Примером может являться задача, у которой мы не можем определить заранее количество повторений. Данная тема будет рассмотрена вскользь, так как циклы `for` являются гораздо более востребованными при разработке в SwiftUI

 Возьмём простой пример обратного отсчёта
 */

var countdown = 10
while countdown > 0 {
	print("\(countdown)…")
	countdown -= 1
}

print("Пуск!")

/*:
 Рассмотрим цикл подробнее

 1. `while` - ключевое слово начала цикла
 2. `countdown > 0` - условие выполнения итерации цикла. Как только условие перестанет выдавать `true`, цикл прервётся и продолжится выполнение кода после
 3. `{ … }` - тело цикла
 4. `countdown -= 1` - важный компонент данного цикла. Без него тело будет выполняться бесконечно, пока программа не завершится с ошибкой. Именно данная проблема является главной причиной непопулярности данного типа циклов

 Прочитать `while countdown > 0 { … }` можно как "пока `countdown` больше 0, выполнить код"

 Теперь пример, в котором цикл `for` будет менее предпочтительным вариантом: бросок кубика на 20 граней, в котором нам нужно получить 20, что в игре Dungeons and Dragons является редким успехом
 */

var roll = 0
while roll != 20 {
	roll = Int.random(in: 1...20)
	print("Бросок на \(roll)")
}

print("Критическое попадание!")

/*:
 - Note:
 У встроенных числовых типов есть полезная функция `random(in:)`, которая принимает на вход диапазон чисел и выдаёт случайное. Мы использовали данную функцию, чтобы "кинуть кубик" и получить значение на верхней грани в строке 139

 Циклы `while` удобны в тех случаях, когда нам нужно выполнить ряд действий в зависимости от условия, не завязанном на фиксированном количестве повторений. Однако есть случаи, когда цикл может и вовсе на начать исполнять код в теле, так как изначально условие `false`. Если же нам необходимо всегда выполнить минимум одну итерацию цикла, нужно использовать модифицированную версию цикла `while` `repeat { … } while <условие>`
 */

var name = "Маша"
var availableNames = ["Маша", "Михайло Иванович", "Настасья Петровна", "Мишутка"]

print()
print("Цикл while:")
while name != "Маша" {
	print("Меня зовут \(name)")
	let newNameIndex = Int.random(in: 0..<availableNames.count)
	name = availableNames[newNameIndex]
}
print()

name = "Маша"
print("Цикл repeat-while:")
repeat {
	print("Меня зовут \(name)")
	let newNameIndex = Int.random(in: 0..<availableNames.count)
	name = availableNames[newNameIndex]
} while name != "Маша"

/*:
 ## Как пропустить элементы в цикле с помощью `break` и `continue`

 В Swift есть два способа пропустить элементы цикла: `break` и `continue`.

 Если нам нужно пропустить неподходящие под условие данные, мы можем сделать это с помощью `continue`, который остановит выполнение текущей итерации цикла и перейдёт к следующему элементу коллекции
*/

let filenames = ["я.jpg", "Заметки.txt", "София.jpg"]

for file in filenames {
	if file.hasSuffix(".jpg") == false {
		continue
	}

	print("Найдена картинка: \(file)")
}

/*:
 - Note:
 Строку 183 можно написать немного иначе в виде `if !file.hasSuffix(".jpg") {`. Этот вариант равнозначен текущей строке и является личным предпочтением по написанию кода. Случай с восклицательным знаком короче, однако он заставляет переводить взгляд с конца условия в начало, чтобы понять инверсию результата, в то время как строка 183 читается как обычный текст и проще для восприятия, особенно неподготовленным людям

 Если нам необходимо полностью прервать выполнение всего цикла, используется `break`. Рассмотрим пример про список покупок, но немного модифицируем для наглядности, а затем рассмотрим альтернативный способ с применением `break`
 */

print()
visibleGroceries = []
print("Без break:")
for i in 0..<groceries.count {
	let item = groceries[i]

	print("Рассматриваем: \(item)")
	if i < 3 {
		print("    Добавляем: \(item)")
		visibleGroceries.append(item)
	}
}
print()
print("Конечный результат: \(visibleGroceries)")
print()
print()

visibleGroceries = []
print("Испоьзуя break:")
for item in groceries {

	print("Рассматриваем: \(item)")
	if visibleGroceries.count == 3 {
		break
	}

	print("    Добавляем: \(item)")
	visibleGroceries.append(item)
}
print()
print("Конечный результат: \(visibleGroceries)")

/*:
 Главное отличие этого способа от предыдущего видно в консоли: в первом случае мы рассмотрели дополнительно 4 элемента прежде чем перейти к следующей части кода. Если представить, что у нас 10 000 000 записей в массиве, а нам нужно отобрать первые 3, тогда приложение может зависнуть на несколько секунд, что не является нормой.

 Во втором же случае мы проверили всего 1 дополнительный элемент и поняв, что нам больше не нужно дальше смотреть элементы массива, с помощью `break` прекращаем выполнение дальнейших итераций
 */
//: [День 5](@previous) | [Содержание](Home) | [Контрольная точка 3](@next)
