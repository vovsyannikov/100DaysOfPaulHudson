import Foundation
//: [Контрольная точка 4](@previous) | [Содержание](Home) | [День 10](@next)
/*:
 # День 9: Замыкания

 ## Как создать и использовать замыкания (`closures`)

 В Swift функции можно присвоить переменным, чтобы использовать их в будущем. Для этого создаётся переменная или константа и ей присваивается функция по имени **БЕЗ** скобок в конце, а вызов производится как обычно
 */

func greetUser() {
	print("Hello there!")
}

greetUser()

let greetCopy = greetUser

greetCopy()

/*:
 Данный пример редко применяется на практике, так как мы должны сначала создать функцию и передать её в переменную. Но здесь мы видим, что можно присвоить не только фиксированное значение или коллекцию в переменную, но и целые блоки с исполняемым кодом

 Здесь мы и посмотрим на такое явление как замыкания. Они позволяет создать блок функциональности, наравне с полноценной функцией, только объявленной в переменной с возможностью передачи в другие функции.

 Для того, чтобы объявить замыкание, мы должны объявить новую переменную или константу и после `=` открыть фигурные скобки. Любой код внутри будет исполнен при вызове, похожем на функцию, с помощью скобок
 */

let sayHello = {
	print("Приветик")
}

sayHello()

/*:
 Как и в функциях мы можем указать дополнительные параметры и возвращаемое значение. Однако формат объявления отличается от функций. Для этого необходимо перечислить все параметры сразу после открытия фигурных скобок, возвращаемое значение и в конце ставится ключевое слово `in`
 */

let greetPerson = { (name: String) -> String in
	"Привет \(name)"
}

/*:
 Возникает закономерный вопрос: зачем? Для чего нужны замыкания, если существуют функции? Ответ заключается в том, что таким образом мы можем модифицировать выполнение функции внесением своих изменений во время исполнения. Замыкания используются повсеместно в Swift, SwiftUI и других местах. Они лишь кажутся сложными и непонятными, но это важная часть разработки на Swift

 Прежде чем понять зачем нам нужны замыкания, рассмотрим то, как они формируются. Ранее мы создали переменную для хранения функции. А какого она типа? Функция, которая не принимает никаких параметров, не возвращает никаких значений и не кидается ошибками. Пропишем новую константу на основе нашей функции `greetUser`
 */

let greetCopyTyped: () -> Void = greetUser

/*:
 Поскольку это функция без параметров мы объявляем и вызываем её с пустыми скобками. Значит в типе будет точно такое же объявление

 `Void` - означает пустота. Значит функция возвращает пустое значение. Прописывать возвращаемое значение обязательно, если мы хотим вручную объявить тип переменной

 - Note:
 Запись, формата `() -> Void`, иногда можно встретить в виде `() -> ()`. Это равнозначные записи, но визуально получается каша из скобок. Когда мы пишем `Void`, мы явно говорим, что это пустое возвращаемое значение

 В отличии от функций, для замыканий не важны имена параметров:
 */

func getUserData(for id: Int) -> String {
	if id == 1989 {
		return "Тейлор Свифт"
	} else {
		return "Anonymous"
	}
}

let data: (Int) -> String = getUserData
let user = data(1989)

print(user)

/*:
 Даже при том, что в оригинальном виде функция `getUserData(for:)` имеет внешнее имя параметра, в копии этот факт затирается и при вызове нашей константы `data`, мы не пишем `let user = data(for: 1989)`

 А что на счёт замыкания `greetPerson`, которое мы создали полностью вручную без изначальной функции? Как вызвать её? В таком же виде, как и `data` выше:
 */

let userGreeting = greetPerson(user)
print(userGreeting)

/*:
 Пришло время осознать всю мощь замыканий и понять таки наконец, для чего они нужны. Ранее мы пользовались функцией `sorted()` для сортировки коллекций. Это лишь один вариант использования. Эту функцию можно модифицировать с помощью замыканий. Освежим в памяти обычную сортировку
 */

let characters = ["Крокодил Гена", "Чебурашка", "Шапокляк", "Крыска Лариска"]
let sortedCharacters = characters.sorted()
print(sortedCharacters)

/*:
 А что если мы хотим, чтобы Чебурашка всегда был в верху списка? Мы можем написать функцию, которая сделает особую проверку для модификации `sorted()`
 */


func sortingAlgorithm(name1: String, name2: String) -> Bool {
	if name1 == "Чебурашка" {
		return true // Если Чебурашка это первое имя сравнения, тогда он на своём месте
	} else if name2 == "Чебурашка" {
		return false // Если Чебурашка это второе имя сравнения, тогда второе имя должно идти до первого
	}

	return name1 < name2 // Для любого другого имени просто сравниваем по алфавиту
}

/*:
 Теперь когда наша сортировочная функция написана, её надо использовать в варианте `sorted(by:)`, который, по абсолютному совпадению, похож по типу на нашу функцию
 */

let cheburashkaFirstCharacters = characters.sorted(by: sortingAlgorithm)
print(cheburashkaFirstCharacters)

/*:
 Мы рассмотрели два очень важных момента:

 1. Мы можем создавать блоки исполняемого кода как переменные и использовать их в дальнейшем как обычные функции
 2. Мы можем передавать функции в другие функции для модификации их работы

 Теперь объединим эти два момента, поскольку для замыканий как параметров функций неважно, передаём мы уже готовые функции или замыкания или же напрямую пишем их имплементацию

 **ПРЕДУПРЕЖДЕНИЕ**:
 Сильные мигрени и пониженная самооценка могут возникнуть при просмотре следующего блока кода. Это нормально для первого раза: это не читатель тупой, а замыкания экстремально сложные к осознанию
 */

let shpoklyakFirstCharacters = characters.sorted(by: { (name1: String, name2: String) -> Bool in
	if name1 == "Шапокляк" {
		return true
	} else if name2 == "Шапокляк" {
		return false
	}

	return name1 < name2
})

print(shpoklyakFirstCharacters)

/*:
 За исключением имени для сравнения, весь код после `in` буквально скопирован из нашей отдельной функции `sortingAlgorithm`.

 Что важно для нас, так как это строка `sorted(by: { (name1: String, name2: String) -> Bool in … })`. В данном случае мы применяем механизм встроенных замыканий, когда мы не определяем отдельную функцию или переменную, а на месте пишем код, специфичный для данной реализации

 В следующей главе рассмотрим способы сократить код для лучшей читаемости

 ---

 ## Как использовать хвостовые замыкания и сокращённый синтаксис

 В примерах, где мы использовали `sorted(by:)` мы указывали конкретные типы данных: для двух параметров `String` и для возвращаемого значения `Bool`. Это связано с натурой Swift и его строгой типизированности: если функция должна принять две строчки и вернуть булево значение, другого исход быть не может. Это может быть функция или замыкание или встроенное замыкание, не важно. Главное, чтобы все параметры и возвращаемое значение совпадали с исходным объявлением. А значит, если все типы фиксированы, в объявлении замыкания их можно опустить:
 */

let sortedCharacters1 = characters.sorted(by: { a, b in
	if a == "Шапокляк" {
		return true
	} else if b == "Шапокляк" {
		return false
	}

	return a < b
})

/*:
 Но и это ещё не всё. Если функция принимает на вход параметром замыкание и оно находится в конце, мы можем "подрезать хвост" и оставить лишь наше замыкание. В таком случае мы убираем вторые скобки в конце и весь вызов функции выглядит как условие или цикл:
 */

let sortedCharacters2 = characters.sorted { a, b in
	if a == "Шапокляк" {
		return true
	} else if b == "Шапокляк" {
		return false
	}

	return a < b
}

/*:
 -Note:
 При объявлении замыкания `sortedCharacters2` мы убрали скобки у параметров и тут становится ясно, для чего нужно ключевое слово `in`: оно означает конец объявлений и начало тела замыкания

 Последнее, что можно упростить - сами имена. Когда Swift знает все параметры замыкания, мы можем использовать сокращённый синтаксис в теле. Каждая переменная в таком случае начинается с `$` и порядковый номер начиная с 0. Наша сортировка в таком случае будет выглядеть так:
 */

let sortedCharacters3 = characters.sorted {
	if $0 == "Шапокляк" {
		return true
	} else if $1 == "Шапокляк" {
		return false
	}

	return $0 < $1
}

/*:
 Такая форма записи может отпугнуть. В данном случае лучше использовать 2 вариант, где мы указываем имена вручную, так как мы используем параметры несколько раз

 Использовать третий вариант замыканий лучше, когда всё тело можно записать в одну строку, например, если мы хотим вывести наш массив персонажей в обратном порядке:
 */

let reverseCharacters = characters.sorted { $0 > $1 }

/*:
 -Note:
 Поскольку `reverseCharacters` не имеет особой логики для сортировки, а замыкание буквально состоит из одной строки, мы имеем полное право опустить слово `return` как и в функциях и оставить тело замыкания на то же строке, что и объявление

 В конвенции Swift не существует правил когда использовать сокращённый синтаксис, а когда более полный. Хорошими ориентирами могут послужить несколько пунктов, когда использовать собственные имена:

 1. Если тело замыкания занимает больше 3-4 строк
 2. Если переменные в замыкании используются больше 1 раза
 3. Если самих параметров больше 2 (`$0` и `$1` считать максимально возможным количеством)

 Для тех, кто всё ещё считает замыкания чем-то неестественным, приведу несколько примеров

 Отфильтруем наш массив персонажей по первой букве. Если имя начинается с "К", тогда мы элемент берём в результат
 */

let kOnlyCharacters = characters.filter { $0.hasPrefix("К") }
print(kOnlyCharacters)

//: Теперь создадим массив, в котором все имена персонажей будут заглавными буквами

let uppercasedCharactes = characters.map { $0.uppercased() }
print(uppercasedCharactes)

/*:
 - Note:
 Функция `map()` может не только изменять сами значения, но и создать новый массив. Например, если мы хотим массив чисел перевести в массив строк

 Подобные функции используются повсеместно в SwiftUI, хотим мы вывести массив людей на экран, нам надо данные трансформировать в различные элементы на экране или же кнопки, для которых нужно указать два параметра: действие и внешний вид, которые могут быть заданы замыканиями

 ---

 ## Как передавать замыкания в функции

 Мы уже рассмотрели несколько вариантов того, как использовать функции с функциями в параметрах. Осталось написать подобную функцию самому, на примере генератора массива чисел. Мы создадим генератор, в который передадим количество элементов и функцию как генерировать число
 */

func makeArray(size: Int, using generator: () -> Int) -> [Int] {
	var result = [Int]()

	for _ in 0..<size {
		let value = generator()
		result.append(value)
	}

	return result
}

/*:
 Тело функции довольно тривиальное, а вот объявление уже интересней. Мы объявляем замыкание `generator` в точности как и обычную константу из первой главы. Скобки означают, что в это замыкание никаких параметров передавать не будет, но она обязана вернуть число. Потому мы можем вызывать генерировать значения, которые приду к нам извне

 Остаётся только вызвать
 */

let rolls20 = makeArray(size: 50) {
	Int.random(in: 1...20)
}

func roll6() -> Int {
	Int.random(in: 1...6)
}

let rolls6 = makeArray(size: 50, using: roll6)

/*:
 - Note:
 Мы можем использовать внешние функции для передачи в `makeArray` без дополнительных модификаций

 Так же имеется возможность передавать несколько замыканий в функцию и использовать особую форму хвостовых замыканий, если они указаны последними. Рассмотрим максимально серьёзный пример
 */

func doImportantWork(first: () -> Void, second: () -> Void, third: () -> Void) {
	print("Начинаем первое задание")
	first()
	print("Начинаем второе задание")
	second()
	print("Начинаем третье задание")
	third()
	print("Работа закончилась")
}

/*:
 Теперь вызовем этот неимоверный шедевр кода. Поскольку у нас несколько замыканий в конце, для их идентификации мы должны прописать внешнее имя параметра с двоеточием перед началом тела. Только первое замыкание не имеет имени в начале
 */

doImportantWork {
	print("  Первое задание")
} second: {
	print("  Второе задание")
} third: {
	print("  Третье задание")
}

/*:
 Смотря на этот ужас пролетает мысль в голове: и кому только может понадобится 3 замыкания? А я отвечу: SwiftUI! Там для того чтобы создать список элементов (например, лента новостей), мы можем делать секции, где в первом замыкании будут сами элементы, во втором - вид заголовка и в третьем - вид подвала секции
 */

//: [Контрольная точка 4](@previous) | [Содержание](Home) | [День 10](@next)
