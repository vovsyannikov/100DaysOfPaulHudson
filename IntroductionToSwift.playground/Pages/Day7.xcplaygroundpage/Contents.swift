import Foundation
//: [Контрольная точка 3](@previous) | [Содержание](Home) | [День 8](@next)
/*:
 # День 7: Функции (Часть 1)

 ## Как переиспользовать код с помощью функций

 Порой возникает необходимость использовать код несколько раз в множестве мест. Это можно сделать с помощью копирования, но если в будущем захочется изменить что-то в логике, придётся делать это в каждом месте, где был использован этот код. Чтобы избежать подобных проблем, а так же для выделения отдельных блоков для наглядности и существуют функции. Функции похожи на константы и переменные, рассмотренные ранее, только вместо хранения данных они будут выполнять какую-то работу

 Рассмотрим пример приветственного сообщения для пользователя:
*/

func showWelcome() {
	print("Добро пожаловать в приложение!")
	print("По умолчанию здесь выводится сводная")
	print("таблица переводов сантиметров в дюймы, но вы")
	print("можете установить свои диапазоны если пожелаете")
}

/*:
 1. `func` - Ключевое слово для объявления функции
 2. `showWelcome` - Название функции, по которому в будущем к ней необходимо обращаться
 3. `()` - Круглые скобки означают набор параметров. Если они пустые, значит для работы функции не нужно ничего в неё передавать.
 4. `{ … }` - Тело функции, где происходит вся работа

 - Note:
 Для переменных/констант и функций принято давать понятные имена. 

	Поскольку переменные и константы хранят данные, их название должно чётко, ясно и, по возможности, кратко (либо с простыми, либо вовсе без сокращений) отражать, что именно здесь хранится: `temperature`, `welcomeText`, `isValid` и т.д. Имена на подобии `p`, `cnt`, `veryCoolNumberThatIReallyLike` должны быть отправлены в ад. Примерами приемлемых названий могут считаться `min`/`max`, `avg`, `i` (для счётчиков в циклах) и прочие

	Функциям же, как для набора действий, следует давать имена, означающие чем именно занимается функция: `showWelcome`, `downloadData`, `updateEntity` и прочие

 Чтобы заставить нашу функцию работать, нужно её вызвать:
 */

showWelcome()

/*:
 `showWelcome()` не принимает в себя никаких аргументов, так как для её работы не нужны дополнительные элементы. Однако существует потребность в том, чтобы функция выдавала разный результат в зависимости от передаваемых в неё значений. Мы уже сталкивались с примерами подобных функций:
 */

let number = Int.random(in: 1...100)

var result = "Число \(number): "
if number.isMultiple(of: 2) {
	result.append("Чётное")
} else {
	result.append("Нечётное")
}

print(result)

/*:
 - Note:
 `Int.random(in:)` не имеет смысла без указания диапазона после `in:`. Что должно произойти, если бы мы не указывали границы выборки? В Swift переменная/константа тип `Int` может хранить числа в промежутке между -9 223 372 036 854 775 808...9 223 372 036 854 775 807. Нам нужен случайный элемент среди **ВСЕХ** возможных значений? Или только положительных? Очень редко нужно использовать максимально возможные значения для типа данных, но часто приходится работать с количеством фотографий в папке или вариантов блюд в меню

	Тоже самое можно сказать и про `a.isMultiple(of: b)`. Данная функция возвращает `true`, если число `a` делится без остатка на число `b`. А что означает `a.isMultiple()`? На что мы делим `a`? В примере из строчек 45-49 мы смотрим, является ли число чётным или нечётным. Данный функционал можно было бы реализовать с помощью функции `isEven()`, которая, по сути, выполняет `a.isMultiple(of: 2)`. Таким образом `isMultiple(of:)` является более универсальной функцией, в которой мы можем узнать не только чётность, но и возможность деления без остатка на любое число

 Давайте создадим свою функцию, которая выведет в консоль таблицу умножения для указанного числа
 */

func printTimesTable(number: Int) {
	print()
	print("Таблица умножения для \(number)")
	for i in 1...10 {
		print("    \(number) x \(i) = \(number * i)")
	}
}

/*:
 Стоит обратить внимание на код внутри круглых скобок: `(number: Int)`. Таким образом мы говорим Swift, что данная функция должна принять на вход число типа `Int` и вне зависимости от того, какое она имеет название (если имеет) в месте вызова, в теле функции она будет называться `number`

 Теперь чтобы распечатать таблицу умножения для числа, необходимо вызвать эту функцию:
 */

printTimesTable(number: 2)
printTimesTable(number: 4)

/*:
 - Note:
 В отличии от многих других языков программирования при вызове параметризованных функций мы не можем написать `printTimesTable(2)`. В Swift мы должны указать имя аргумента, для которого передаём значение: `printTimesTable(number: 2)`. Это удобно в случаях, когда нам необходимо передать несколько значений. Без этих меток в месте вызова будет непонятно какой аргумент за что отвечает. Например, если мы создадим схожую функцию с текущей реализацией таблицы умножения, для которой будем вручную указывать верхнюю границу счёта, то весь код будет выглядеть так:
 */

func printTimesTable(number: Int, end: Int) {
	print()
	print("Таблица умножения от 1 по \(end) для \(number)")
	for i in 1...end {
		print("    \(number) x \(i) = \(number * i)")
	}
}

printTimesTable(number: 6, end: 12)

/*:
 Каждый параметр и аргумент разделяется запятой и для каждого указывается имя, как в объявлении, так и в вызове соответственно. Порядок параметров в месте вызова должен так же быть идентичен объявлению. То есть если мы сделали функцию `printTimesTable(number: Int, end: Int)`, мы не сможем вызвать её как `printTimesTable(end: 12, number: 5)`, Swift выдаст ошибку

 Любые переменные/константы, созданные внутри тела функции, а также полученные на вход копии данных в виде параметров, будут уничтожены при достижении закрывающих скобок

 - Note:
 Понятия аргумент и параметр функции звучат схоже и даже используются зачастую (большую часть времени) взаимозаменяемо, однако между ними есть тонкая грань:

	- Параметр функции - константа или переменная, используемая функцией внутри своего тела
	- Аргумент функции - фактическое значение, передаваемое в функцию

	Для избежания путаницы в терминологии далее будет использоваться термин параметр для описания обоих значений

 ---

 ## Как возвращать значения из функций

 Мы рассмотрели функции, которые выполняют набор действий. Они могут работать как с входными данными, так и без. Однако функции могут возвращать результат своей работы обратно, чтобы продолжить работу с ним в другом месте. Мы уже рассматривали подобные функции. Среди них `sorted()`, которая сортирует коллекцию и возвращает её обратно или `uppercased()`/`lowercased()`, которые меняют регистр всех букв в строке и отдают обратно уже трансформированную строку. Это лишь малая часть встроенных функций в библиотеку `Foundation` и её macOS альтернативе `Cocoa`. Есть особая функция, которая считает корень числа, переданного в виде параметра. Например, мы хотим получить квадратный корень из 169 и затем вывести в консоль:
 */

let root = sqrt(169)
print(root)

/*:
 Наличие таких функций как `sqrt()` для вычисления квадратного корня, наводит на мысль, что мы можем писать такие же функции. Для этого в объявлении необходимо добавить после круглых скобок следующую конструкцию: -> <тип возвращаемого значения>
 */

func rollDice() -> Int {
	return Int.random(in: 1...6)
}

/*:
 Функция `rollDice()` занимается броском кубика на 6 граней. Мы указали `() -> Int`, что означает мы не принимаем на вход никакие данные, но должны вернуть целое число в конце

 Если мы посмотрим в тело данной функции, то увидим в конце новое ключевое слово `return`. Оно означает, что на данной строке производится выход из функции и возврат значения, случайное число от 1 по 6

 Как и в случае с типами данных, Swift очень серьёзно относится к функциям. **Функция обязана вернуть значение указанное в объявлении**. Нельзя просто выполнить код и не отправить обратно число или вместо этого кинуть строку или любой другой тип данных. В противном случае программа попросту не начнёт выполнение, так как Xcode будет ругаться громко и настойчиво

 Рассмотрим пример посложнее. Напишем функцию, которая примет на вход две строки и вернёт `true`, если все символы строк совпадают
 */

func lettersIdentical1(string1: String, string2: String) -> Bool {
	let first = string1.sorted()
	let second = string2.sorted()

	return first == second
}

/*:
 Для решения данной проблемы мы сортируем обе строки, в таком случае нам не важно, в каком порядке они находятся изначально. Но `lettersIdentical1(string1:, string2:)` можно упростить. Сейчас мы создаём две переменные `first` и `second` для хранения результата сортировки первой и второй строк соответственно. Мы можем использовать результат сортировки напрямую при сравнении:
 */

func lettersIdentical2(string1: String, string2: String) -> Bool {
	return string1.sorted() == string2.sorted()
}

/*:
 Теперь функция `lettersIdentical2(string1:, string2:)` выполняет ту же работу, но за меньшее количество строк. Но и это ещё не всё. Swift знает, что данная функция должна вернуть булевое значение и, поскольку функция состоит из одной строки, она обязана вернуть тот самый требуемый результат, а значит ключевое слово `return` можно опустить:
 */

func lettersIdentical3(string1: String, string2: String) -> Bool { string1.sorted() == string2.sorted() }

/*:
 Теперь вся функция `lettersIdentical3(string1:, string2:)` может занять одну строку. Такой формат написания имеет место быть, однако в целом лучше писать тело функции на отдельной строке и конечную фигурную скобку на отдельной, то есть стоит придерживаться формату написания представленному выше

 - Note:
 Ключевое слово `return` можно использовать в функциях, которые ничего не возвращаю. Для этого просто пишется `return`. Например, нам нужно завершить выполнение функции, так как пользователь ввёл некорректные данные, которые мы не можем обработать. В таком случае произойдёт немедленный выход и весь последующий код выполняться не будет

 ---

 ## Как вернуть несколько значений из функции

 Порой возникает необходимость вернуть из функции несколько значений. До этого момента мы возвращали числа, строки и булевые значения. Но что если нам надо вернуть набор данных о пользователе? Можно использовать массивы:
 */

func getUserArray() -> [String] {
	["Клава", "Кока"]
}

let userFromArray = getUserArray()
print("Приветствую \(userFromArray[0]) \(userFromArray[1])")

/*:
 В данном случае мы возвращаем массив с именем и фамилией. Для разработчика, который впервые увидит строки 171 и 172, будет непонятно что хранится в `userFromArray` на каждом из индексов и придётся каждый раз лезть в функцию., чтобы это выяснить. А что если в будущем на индекс 0 мы захотим назначить уникальный идентификатор в системе или объединим имя и фамилию в одно значение и массив будет состоять из одного элемента. Данный вариант не подходит

 Рассмотрим вариант возвращать словарь
 */

func getUserDict() -> [String: String] {
	["firstName": "Клава", "lastName": "Кока"]
}

let userFromDict = getUserDict()
print("Приветствую \(userFromDict["firstName", default: "?"]) \(userFromDict["lastname", default: "?"])")

/*:
 Уже лучше. Теперь мы явно пытаемся получить имя и фамилию из словаря и в случае, если что-то поменяется в будущем, наше приложение не упадёт. Однако возникает ряд других проблем. Например, я допустил опечатку при попытке получить фамилию и теперь там всегда будет выводиться значение по умолчанию. Этот момент можно исправить с помощью перечисления, но такой вариант добавит ко второй проблеме - громоздкость кода в месте вызова, который и так выглядит огромным. Тоже не оптимальный вариант

 Для подобных задач были созданы кортежи (`tuples`). Кортеж представляет собой фиксированный набор разнотипных данных. В него можно поместить неограниченное количество значений, но добавить новое после создания не получится. Так же каждый из элементов может иметь название, которое будет чётко отражать его назначение. Попробуем переписать наш пример используя кортежи
 */

func getUserTuple() -> (firstName: String, lastName: String) {
	(firstName: "Клава", lastName: "Кока")
}

let userFromTuple = getUserTuple()
print("Приветствую \(userFromTuple.firstName) \(userFromTuple.lastName)")

/*:
 Разберём нашу функцию `getUserTuple()`, а точней что она возвращает

 1. `(firstName: String, lastName: String)` - Тип возвращаемого значения. Так обозначается кортеж: круглые скобки, через запятую указывается каждый элемент. Мы сказали, что у нас будет `firstName` типа `String` и `lastName` типа `String`. Имена указываются без кавычек, как будто объявляем переменную или константу
 2. `(firstName: "Клава", lastName: "Кока")` - Кортеж данных. В нём мы указываем те же имена элементов, что и в объявлении функции, в том же порядке. После имени элемента кортежа стоит доветочие, после которого указывается значение. Поведение схоже с элементами словаря, где мы указываем их в формате <ключ>: <значение>

 У кортежей есть ряд отличий от словарей и массивов:

 1. В кортежах мы уверены на 100%, что значение будет существовать. У словарей такого значения может не оказаться к моменту чтения, а массивы и вовсе вызовут критическое падение приложения, если мы попытаемся достать несуществующий элемент
 2. Словари, у которых в виде ключа указана строка, могут оказать проблемной точкой, если разработчик сделает ошибку в имени. Массивы оперируют на основе числовых индексов, которые не дают достаточно информации о значении. Для кортежей существуют подсказки компилятора, который подсказывает все возможные варианты
 3. Кортежы позволяют увидеть заранее весь набор данных. Когда разработчик нажимает точку для получения одного из элементов кортежа, высветится их полный список. В словарях и массивах, помимо нужных нам элементов может содержаться сотни других элементов, среди которых придётся искать нужный

 У кортежей есть пара занятных моментов:

 1. Мы можем не прописывать имена для элементов кортежа. Получить доступ к элементам всегда можно с помощью числового представления
 2. Если мы возвращаем кортеж с именами из функции, мы можем просто перечислить все поля в месте возврата

 Рассмотрим на примере
 */


func getUserTuple2() -> (String, lastName: String) {
	("Клава", "Кока")
}

let userFromTuple2 = getUserTuple2()
print("Приветствую \(userFromTuple2.0) \(userFromTuple2.1)")

/*:
 Посмотрим внимательней на строки 221 - 225:

 1. В данном случае мы возвращаем кортеж, где у первого элемента не указано имя, а значит получить доступ к нему можно с помощью `.0`.
 2. Мы просто прописали `("Клава", "Кока")` в месте возврата функции, опустив имя `lastName` для второго элемента. Так как функция знает, что и как должно называться, а порядок элементов всегда фиксированный, такая форма записи является абсолютно нормальной
 3. Когда мы получаем значения из `userFromTuple2` мы берём их числовые индексы. Для первого элемента имени, который ранее назывался `firstName`, мы не можем иначе, так как у него попросту отсутствует название, но и для фамилии (`lastName`) мы можем указать числовой индекс, который скрыт по причине наличия более удобного формата определения через имя

 - Note:
 Числовых индексов для элементов кортежа стоит по максимуму избегать. Если их использование оправданно, стоит посмотреть в сторону других типов данных, вроде массивов

 Элементы кортежа можно так же разделить на отдельные константы, если такой способ работы более предпочтителен:
 */

let (firstName, lastName) = getUserTuple()
print("Приветствую \(firstName) \(lastName)")

/*:
 Данный принцип называется деструктуризация, когда мы берём структуру и разбиваем её на отдельные компоненты. Чтобы разбить кортеж на его составные части, нужно объявить константу или переменную и указать в скобках через запятую имена для каждого элемента

 - Note:
 Если нам не нужен один или несколько элементов кортежа при разбиении, то вместо имени можно поставить `_`

		let (firstName, _)  = getUserTuple()

 ---

 ## Как изменить метки параметров функций

 В Swift разработчики любят указывать имена параметров для функций, которые они вызывают. Для примера посмотрим на следующий кусок кода:
 */

func rollDice(sides: Int, count: Int) -> [Int] {
	var rolls = [Int]()

	for _ in 1...count {
		let roll = Int.random(in: 1...sides)

		rolls.append(roll)
	}

	return rolls
}

let rolls = rollDice(sides: 6, count: 4)

/*:
 Именно благодаря меткам строка 273 является достаточной для понимания того, что делает вызываемая функция. Не придётся лезть и проверять, чем же она занимается

 В программировании есть понятие перегрузка методов, в котором мы можем назвать несколько функций одним и тем же именем, но с отличием в параметрах которые они принимают. Например, одна функция может быть без параметров, вторая принимает одно целое число, третья - одно дробное число, а четвёртая имеет несколько чисел как параметры. Swift же позволяет также перегрузить функции на основе их меток:
 */

func createObject() {}
func createObject(size: Int) {}
func createObject(size: Double) {}
func createObject(size: Double, name: String) {}
func createObject(size: Double, location: String) {}

/*:
 Обратите внимание, что все 5 функций имеют идентичное название, а последние две даже имеют одинаковые параметры на входе. Но из-за того, что они называются по разному, значит и сами функции выполняют разные задачи

 Но что если я скажу, что иногда эти метки могут быть более губительны, чем полезны? Посмотрим пример функции `hasPrefix()`, которая проверяет наличие префикса в строке
 */

let lyric = "I see a red door and I want it painted black."
print(lyric.hasPrefix("I see"))

/*:
 Заметьте, что мы не пишем `lyric.hasPrefix(string: "I see")` или `lyric.hasPrefix(name: "I see")`. Как так? Почему? Как выясняется в Swift для параметров функций мы можем указать два имени: внешнее и внутренне. Если мы указываем лишь одно, как всё это время в курсе, тогда оно будет использовано как внутри тела функции, так и в месте вызова. Соответственно если указать второе имя, то первой будет использоваться для внешних наблюдателей, а второе, которое ближе к типу - внутри функции

 Чтобы не указывать никакое имя в месте вызова, мы можем просто написать `_` как внешнее имя. Посмотрим на примере функции, которая выясняет, прописана ли строка полностью заглавными буквами
 */

func isUppercased(string: String) -> Bool {
	string == string.uppercased()
}

let string = "HELLO, WORLD!"
var stringIsUppercased = isUppercased(string: string)

/*:
 Некоторые люди (автор в их числе) могут взглянуть на строку 307 и съёжиться от двойного использования слова `string` в вызове функции. Данная функция очевидно принимает на вход строку (`String`), а не число. Так не логичней ли опустить `string:` и сделать `isUppercased(string)`? Автор считает, что да, а потому он приведёт пример
 */

func isUppercased(_ string: String) -> Bool {
	string == string.uppercased()
}

stringIsUppercased = isUppercased(string)

/*:
 Заметьте, что объявление внешнего имени параметра (`_`) стоит первым и через пробел стоит внутреннее имя (`string`). Таким образом мы говорим Swift, что мы не хотим прописывать для данного параметра имя при вызове

 Подобные функции используются повсеместно Swift. Мы уже посмотрели в ходе данного курса на малую их часть, такие как `print()`, `append()`, `sqrt()` и другие

 Но бывают и случаи, когда мы хотим называть наш параметр при вызове функции, однако внутреннее имя не совсем подходит. Рассмотрим функцию печати таблицы умножения под новым углом
 */

func printTimesTable(for number: Int) {
	print("Таблица умножения числа \(number)")
	for i in 1...10 {
		print("    \(number) x \(i) = \(number * i)")
	}
	print()
}

printTimesTable(for: 7)

/*:
 Данный пример читается гораздо приятней чем предыдущий вариант, где мы писали `printTimesTable(number: <значение>)` и практически не отличается от схожей фразы на английском языке

 - Note:
 Мы не можем написать:

		func printTimesTable(for: Int) {
			print("Таблица умножения числа \(for)")
			for i in 1...10 {
				print("    \(for) x \(i) = \(for * i)")
			}
			print()
		}

	Swift начнёт ругаться из-за того, что мы используем ключевое слово как имя переменной, что недопустимо в любом языке программирования, так как смысл ключевых слов в том, чтобы обозначать начало цикла или объявление переменной и т.д.

	Так же проблема данного подхода в том, что даже если бы такой вариант сработал, мы решили одну проблему и добавили новую. Теперь вызов функции выглядит более органично и естественно, но внутри функции у нас мракобесие, где нам надо следить за тем, что делает переменная `for`, когда она превращается в ключевое слово начала цикла и т.д.

 - Note:
 Возвращаясь к вопросу аргументов и параметров, в случае с внешними и внутренними именами мы должны использовать термины "метка аргумента" и "имя параметра" соответственно, что будет вводить разработчиков собеседников в ещё большее уныние и конфуз. Потому в дальнейшем для описания данного феномена будут использоваться внешнее и внутреннее имя параметра
 */
//: [Контрольная точка 3](@previous) | [Содержание](Home) | [День 8](@next)
