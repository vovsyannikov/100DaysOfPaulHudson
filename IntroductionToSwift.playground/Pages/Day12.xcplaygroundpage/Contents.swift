import Foundation
//: [Контрольная точка 6](@previous) | [Содержание](Home) | [Контрольная точка 7](@next)
/*:
 # День 12: Классы

 ## Как создать свой класс

 Мы уже рассмотрели основу Swift - структуры. На них построены все основные типы данных, вроде целых чисел, строк, булевых значений, массивов и т.д. Но это не единственный способ создать свой собственный тип данных. Существуют так же классы. Рассмотрим главные сходства классов и структур:

 1. Можно давать свои имена имена
 2. Можно объявлять свойства, методы, наблюдателей свойств и управлять уровнями доступа
 3. Можно создавать собственные инициализаторы

 Однако классы были бы не нужны, если они идентичны структурам. Вот главные отличия классов от структур:

 1. Классы могут "наследовать" свойства и методы от другого класса. Их можно оставить как есть или изменить под нужды нового объекта
 2. Классы не имеют инициализатора по умолчанию (кроме пустого), так как при наличии "родителя" такая функция может быть огромной. Потому надо либо писать собственный инициализатор (или несколько), либо всем свойствам дать исходные значения
 3. Для классов доступна особая функция деинициализатора (`deinit`). Прежде чем уничтожить последний экземпляр класса, вызовется этот метод, в котором мы можем провести последние зачистки данных
 4. Классы являются объектами ссылочного типа. Это означает, что при копировании экземпляра класса из одной переменной в другую, данные будут меняться в обоих местах. Структуры - это тип значений (value type), что означает при копировании будет создана новая структура со всеми свойствами из оригинала и обе версии независимы друг от друга
 5. Из предыдущего пункта вытекает и возможность менять свойства экземпляра класса, даже если он объявлен как константа. Поскольку при создании в нашу константу или переменную помещается ссылка на объект, а не сам объект, то мы не сможем сменить саму ссылку. Данные же лежат в отдельном месте, в отличии от структур

 Я уже слышу вопрос: а какого хрена существуют классы, если структуры и так работают идеально? Не идеально. SwiftUI обожает структуры: все встроенные типы данных, все UI элементы созданы на основе структур. Но именно из-за п.4 различий классы являются предпочтительными для моделей данных. Мы можем создать модель объекта из базы данных, например. Теперь, передавая ссылку на этот объект из окна в окно мы будем смотреть на одни и те же данные. Внеся изменения на одном экране, они тут же отобразятся на другом. Данные всегда будут оставаться актуальными, что было бы намного сложней организовать со структурами

 - Note:
 Стоит отметить, что так было не всегда. Структуры являлись объектами второго сорта и практически во всех средах front-end разработки, классы являются основой. Даже в устаревающем UIKit, предыдущем фреймворке Apple для разработки интерфейсов, используются классы повсюду. Они используют наследование по полной программе и другие особенности классов

 Стоит поговорить про деинициализацию поподробней. Поскольку класс - это ссылочный тип данных, он хранится в особом месте памяти, так называемой куче. Она не безгранична, а потому при переполнении возникают утечки памяти: блоки данных, которые никак не используются, но занимают место. Чтобы такого не происходило, у классов существует скрытое значение количества ссылок на объект. Если хотя бы один экземпляр указывает на данный блок памяти с нашим классом, эта память будет занята. Как только последняя ссылка будет очищена, класс может освободить блок памяти и вызвать деинициализатор

 Ну и как же без примера после этого водопада букв
 */

class Game {
	var score = 0 {
		didSet { print("Счёт: \(score)")}
	}
}

let game = Game()
game.score += 10 // Не смотря на то, что мы создали константу, мы всё ещё можем менять данные внутри класса

/*:
 ## Как наследовать классы

 Классы умеют строить свой функционал на основе другого класса. Этот процесс называется наследование, класс, взятый за основу, называют "родителем" (parent class) или супер классом (`super` class), а "наследника" зовут ребёнком (child class). Наследники могут использовать свойства и методы родителя, а так же "перезаписать" (`override`) их

 Рассмотрим пример наследования на примере Сотрудника и двух классов "детей", Разработчик и Менеджер
 */

class Employee {
	let hours: Int

	init(hours: Int) {
		self.hours = hours
	}

	func printSummary() {
		print("Я работаю около \(hours) часов в день")
	}
}

final class Developer: Employee {
	func work() {
		print("Я пишу код около \(hours) часов в день")
	}

	override func printSummary() {
		print("Я могу работать \(hours) часов в день, но часто я провожу часы на споры о том, стоит ли делать отступы с помощью табуляторов или пробелов")
	}
}

final class Manager: Employee {

	func work() {
		print("Я хожу на совещания около \(hours) часов в день")
	}
}

let ivan = Developer(hours: 8)
let kirill = Manager(hours: 10)

ivan.work()
kirill.work()

ivan.printSummary()
kirill.printSummary()

/*:
 Начнём с начала. У нас есть суперкласс Сотрудник, у которого есть свойство `hours` и метод для вывода сообщения. Здесь всё точно так же, как и в структурах, за исключением объявления `class` вместо `struct`.

 Самая мякотка начинается в классе Разработчика:

 1. Данный класс начинается со слова `final`. Это означает, что данный класс не может быть унаследован другими. Мы можем применить `final` к конкретным свойствам и методам для ограничения изменений: наследники не смогут поменять логику поведения. По умолчанию лучше делать все классы "финальными", по двум причинам:

	- Никто не сможет нарушить логику работы ненужным или даже вредным расширением функционала
	- Swift производит особую оптимизацию кода для `final` классов, при которой свойства и методы компилируются заранее у класса, а не во время работы приложения. В таком случае вызов будет практически мгновенным

 2. Мы назвали классы `Developer` и `Manager` и "присвоили им тип" `Employee` с помощью двоеточия. Это и есть наследование.
 3. У `Developer` и `Manager` есть уникальные методы `work()`. У них разный результат, поскольку сами методы уникальны
 4. У `Developer` и `Manager` есть доступ к свойству `hours` от родителя. Они могут им распоряжаться как вздумают
 5. У `Developer` и `Manager` есть доступ и к методу `printSummary()`. Но в `Developer` мы решили его переназначить. Для этого используется ключевое слово `override`. Swift будет ругаться, если мы попытаемся перезаписать несуществующий метод или свойство, а также если ничего не изменим в свойствах, но пропишем `override`
 6. Ни для `Developer`, ни для `Manager` мы не вводили новых инициализаторов, однако создаём мы эти объекты с помощью таковой функции от родительского класса `Employee`. Связано это с тем, что у всех трёх классов существует свойство без заданного исходного значения `hours`. И, поскольку мы не указывали новых свойств в детских классах, мы создаём экземпляры с помощью родительской функции создания
 7. Последнее, на что стоит обратить внимание, так это на вывод в консоль от всех вызовов на строках 81 - 85. Они все уникальны для классов, в которых были объявлены

 ---

 ## Как добавить инициализатор классу

 Инициализаторы у классов отличаются от структурных. Сильно отличаются. Для начала у классов с наследованием должен быть обязательный вызов инициализатора родителя после заполнения собственных полей. Посмотрим на примере
 */

// Объявляем класс транспортного средства с одной константой
class Vehicle {
	let isElectric: Bool

	// Создаём простой инициализатор для заполнения свойства
	init(isElectric: Bool) {
		self.isElectric = isElectric
	}
}

// Создадим класс наследник Машина
class Car: Vehicle {
	/// Указание кабрилета
	let isConvertible: Bool

	// Для инициализатора мы должны указать значение как для собственных свойств, так и для родительских
	init(isElectric: Bool, isConvertible: Bool) {
		self.isConvertible = isConvertible

		// После заполнения собственных полей, мы должны вызвать инициализатор суперкласса
		super.init(isElectric: isElectric)
	}
}

let teslaX = Car(isElectric: true, isConvertible: false)

/*:
 - Note:
 С помощью ключевого слова `super` мы можем не только вызвать инициализатор, но и любую другую реализацию метода или свойства родительского класса

 ---

 ## Как копировать классы

 В отличии от структур, при копировании классов мы передаём ссылку на объект, а не сами данные. Потому при изменении значений по ссылке, они будут изменены во всех местах, которые указывают на данный блок памяти

 Но если всё же хочется заиметь копию данных как резервную копию, например. В таком случае посмотрим на несколько примеров со сравнениями со структурами
 */

class UserClass {
	var username = "Аноним"

	func copy() -> UserClass {
		let copy = UserClass()
		copy.username = self.username
		return copy
	}
}

struct UserStruct {
	var username = "Аноним"
}

var userClass1 = UserClass()
var userClass2 = userClass1
var userClass3 = userClass2

var userStruct1 = UserStruct()
var userStruct2 = userStruct1

print()
userClass2.username = "Полина Гагарина"
print("Имя userClass1: \(userClass1.username)")
print("Имя userClass2: \(userClass2.username)")
print("Имя userClass3: \(userClass3.username)")
print()

userStruct2.username = "Полина Гагарина"
print("Имя userStruct1: \(userStruct1.username)")
print("Имя userStruct2: \(userStruct2.username)")

/*:
 Как мы видим у структур копирование работает из коробки, а для классов необходимо создать новый объект с помощью метода и вручную перенести все свойства

 ---

 ## Как создать деинициализатор

 Деинициализатор - это особая функция у классов, которая вызывается при уничтожении последней ссылки на объект. Несколько замечаний по поводу:

 1. Для деинициализаторов, как и для инициализаторов, не указывается слово `func`
 2. Деинициализатор не принимает на вход никаких данных и он ничего не возвращает. Потому круглые скобки не пишутся вовсе
 3. Деинициализатор вызывается, когда последняя ссылка на объект была удалена
 4. Вручную вызвать деинициализатор нельзя. Этим занимается система
 5. У структур не существует деинициализаторов, поскольку каждый экземпляр уникален

 Для понимания всей картины стоит узнать, что такое область видимости (scope). Когда мы создаём переменную или константу в функции, цикле, условии и т.п. мы создаём область видимости. Всё что создано внутри, не видно снаружи. Соответственно, если создать экземпляр класса в функции, тогда он будет жить на протяжении всего её жизненного цикла и будет уничтожен под конец. Для наглядности посмотрим пример
 */

class User {
	let id: Int

	init(id: Int) {
		self.id = id
		// При создании объекта, он напишет об этом в консоль
		print("Пользователь \(id): Создан")
	}

	deinit {
		// При уничтожении объекта, он напишет об этом в консоль
		print("Пользователь \(id): Удалён")
	}
}

for i in 1...3 {
	let user = User(id: i)
	print("Пользователь \(user.id): Живёт")
}
print()

var users = [User]()

for i in 4...6 {
	let user = User(id: i)
	users.append(user)
	print("Пользователь \(user.id): Живёт")
}

print("Конец цикла")
users = []

/*:
 Посмотрим на разницу в поведении первых трёх пользователей и последних. Пользователи 1-3 были удалены как только заканчивалась итерация, в котором они были созданы. Пользователи 4-6 напротив, жили даже после окончания всего цикла. Даже с учётом того, что оригинальная ссылка уже удалена, у нас существовала ещё одна, которую мы поместили в массив. И когда весь список пользователей был очищен, каждый из них был окончательно удалён из памяти

 ---

 ## Как работать с переменными в классах

 Когда мы создаём константу с экземпляром класса мы всё ещё можем менять свойства, которые помечены как переменные. Для простоты понимания скажем, что у нас есть деревня и дорожный знак, указывающий в сторону этой деревни. В будущем название поселения сменилось, но само местоположение на карте осталось прежним. И наш указатель никак не поменялся. Да на нём написано новое название населённого пункта, но стрелка показывает на старое место. Если же мы сделаем наш указатель переменной, тогда мы можем указывать на другую деревню в другом месте. В этом и заключается основная разница
 */

class Village {
	var name = "Простоквашино"
}

var village = Village()
village.name = "Шишкино"
print(village.name)

village = Village()
print(village.name)

//: [Контрольная точка 6](@previous) | [Содержание](Home) | [Контрольная точка 7](@next)
