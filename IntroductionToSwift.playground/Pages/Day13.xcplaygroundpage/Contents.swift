import Foundation
//: [Контрольная точка 7](@previous) | [Содержание](Home) | [Контрольная точка 8](@next)
/*:
 # День 13: Протоколы и расширения

 ## Как создать и использовать протоколы

Протоколы можно представить в виде контрактов: в нём прописываются правила, по которым будут существовать будущие объекта. Это могут быть свойства и методы, описывающие общее поведение для группы объектов

 Например, у нас есть структура Автомобиля и функция для вывода информации о длительности поездки на нём. Затем мы хотим сделать такие вычисления для автобуса, для велосипеда, самолёта и т.д. Для этого нам понадобится создать класс `Vehicle`, который будет является родителем для любых будущих транспортных средств, вроде нашей машины, автобуса и т.д. Но мы уже создали Автомобиль как структуру. Значит надо переписывать всё по новой? Нет. Для этих целей и созданы протоколы. Они позволяют любому типу данных объявить для всех желающих свой гарантированный набор методов и свойств

 Объявим наш протокол `Vehicle` с двумя методами для вычисления времени в пути и проехать некую дистанцию
*/

protocol Vehicle {
	func estimateTime(for distance: Int) -> Int
	func travel(distance: Int)
}

/*:
 Протоколы являются лишь шаблоном. Они говорят о том, что **должно** содержаться в объекте, но сама реализация остаётся на усмотрение конкретных структур, классов и т.д. Именно поэтому наши методы в протоколе не имеют самого тела: мы пишем только как должна называться функция, какие у неё параметры, что возвращает, кидается ли ошибками и мутирует ли она свое состояние (`mutating`)

 Теперь создадим структуру Машины
 */

struct Car: Vehicle {
	func estimateTime(for distance: Int) -> Int {
		distance / 50
	}

	func travel(distance: Int) {
		print("Едем на машине \(distance)км")
	}

	func openSunroof() {
		print("Хороший денёк")
	}
}

/*:
 Пара моментов, которые стоит рассмотреть:

 1. Для реализации протокола, мы пишем его имя как тип у константы или родительский класс. Этот способ схож с наследованием, но доступен любому типу данных без исключений
 2. Теперь все функции, прописанные в протоколе, находятся в нашей структуре. Они имеют идентичные называния, параметры и возвращаемые значения. Только на этот раз мы прописали полноценные тела для этих методов и при их вызове будут происходить указанные нами действия
 3. Мы не обязаны иметь исключительно те методы и свойства, указанные в реализуемом протоколе, о чём свидетельствует метод `openSunroof()`. Они обязаны быть в конечном объекте. В этом и есть главные смысл протоколов

 Теперь посмотрим на ту самую функцию для путешествий
 */

func commute(distance: Int, using vehicle: Vehicle) {
	if vehicle.estimateTime(for: distance) > 100 {
		print("Слишком медленно! Поеду на чём-нибудь другом")
	} else {
		vehicle.travel(distance: distance)
	}
}

let car = Car()
commute(distance: 100, using: car)

/*:
 Вместо того, чтобы указать конкретный тип данных для `vehicle`, мы прописываем туда напрямую имя нашего протокола. Таким образом наша функция может принять любой объект, который реализует протокол `Vehicle`, и использовать все прописанные в нём методы и свойства. Мы теряем доступ к специфичным для конкретного типа поля и функции, но в данном случае нам они и не нужны. Нам не важно, чем ещё может заниматься объект. Главное, что он может посчитать время в пути и начать путешествие

 Но с одним типом неинтересно. Мы могли бы прописать `using vehicle: Car` и всё работало точно так же. Вот тут и начинается магия. Введём новую структуру Велосипеда
 */

struct Bicycle: Vehicle {
	func estimateTime(for distance: Int) -> Int {
		distance / 10
	}

	func travel(distance: Int) {
		print("Крутим педали \(distance)км")
	}
}

let bike = Bicycle()

commute(distance: 50, using: bike)

/*:
 Не меняя ни строчки кода в функции `commute(distance:, using:)` мы сразу же можем использовать её с нашей новой структурой. Это связано с указанным типов данных `vehicle`. Этот параметр не знает, что за объект будет в неё передан, да и не важно это. Главное, что этот объект гарантировано будет иметь свойства и методы из протокола `Vehicle`

 Теперь посмотрим на то, как объявлять свойства в протоколах, так как это не очевидный на первый взгляд процесс. Создадим протокол поселения, у которого будет постоянное имя и меняющееся население, а также будет метод для вычисления потребления энергии
 */

protocol Settlement {
	var name: String { get }
	var population: Int { get set }

	func estimatePowerDraw() -> Int
}

/*:
 Для объявления свойств в протоколе необходимо:

 1. все свойства обозначить как `var`. Даже если мы хотим сделать константу или вычисляемое поле без записи
 2. указать имя и тип данных
 3. в фигурных скобках указать возможные способы обращения:

	- `{ get }` - только запись
	- `{ get set }` - запись и чтение

 Теперь создадим Город и Деревню используя наш протокол
 */

struct City: Settlement {
	let name: String
	var population = 13_149_803

	func estimatePowerDraw() -> Int {
		population * 20
	}
}

struct Village: Settlement {
	let name: String
	var population = 59

	func estimatePowerDraw() -> Int {
		population * 5
	}
}

/*:
 Сила протоколов заключается в том, что мы можем создать массив из разных объектов и использовать их как если бы они были одного типа. 

 - Note:
 Мы также можем возвращать из функций протокол, а точнее тип, реализующий протокол

 Создадим массив из наших поселений, выведем их описание в функции и увеличим
 */

let moscow = City(name: "Москва")
let prostokvashino = Village(name: "Простоквашино")

func estimatePowerDraw(for settlements: [Settlement]) {
	for settlement in settlements {
		let powerDraw = settlement.estimatePowerDraw()
		print("\(settlement.name): \(settlement.population) человек будут потреблять \(powerDraw) КВт/ч")
	}
}

estimatePowerDraw(for: [moscow, prostokvashino])

/*:
 - Note:
 В отличии от наследования, мы можем указать любое количество протоколов для реализации через запятую. Если же класс наследуется от другого класса, тогда имя родителя указывается первым в списке
 */

//: [Контрольная точка 7](@previous) | [Содержание](Home) | [Контрольная точка 8](@next)
