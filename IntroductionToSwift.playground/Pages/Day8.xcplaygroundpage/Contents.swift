import Foundation
//: [День 7](@previous) | [Содержание](Home) | [Контрольная точка 4](@next)
/*:
 # День 8: Функции (Часть 2)

 ## Как предоставить значение по умолчанию для параметра функции

 Добавление параметров в функции позволяет нам изменять конечный результат, подходящий под текущие требования. Некоторые функции в 9 случаях из 10 могут работать и без кастомизации. Но в таком случае надо прописывать одни и те же данные на вход во всех 10 случаях. Можно ли этого избежать? Конечно. Рассмотрим наш код для таблицы умножения. В России принято использовать числа от 1 до 10, а в Британии используют число 12 как конечную точку и т.д. Мы можем при объявлении типа параметра поставить `=` и указать после значение по умолчанию:
 */

func printTimesTable(for number: Int, end: Int = 10) {
	print("Таблица умножения от 1 по \(end) числа \(number)")
	for i in 1...end {
		print("    \(number) x \(i) = \(number * i)")
	}
	print()
}

//: Теперь вызов функции может выглядеть так:

printTimesTable(for: 3)
printTimesTable(for: 6, end: 12)

/*:
 Как мы видим у нас нет необходимости каждый раз указывать конечное значение нашей таблицы умножения, но если нам понадобится вывести британский вариант, такая возможность всё ещё остаётся

 Ранее мы уже рассматривали пример функции с значением по умолчанию: `removeAll(keepingCapacity:)`. Параметр `keepingCapacity` имеет значение по умолчанию `false`. В таком случае при очистке массива он полностью очиститься из памяти. За редким исключением нам надо оставить исходный размер, как в случаях, когда мы хотим быстро поменять один набор значений на другой такого же размера и чтобы оптимизировать работу с памятью мы можем оставить себе её часть и заполнить по новой

 ---

 ## Как обрабатывать ошибки в функциях

 Дела всегда могут пойти не по плану. Если мы пытаемся прочесть несуществующий файл или получить данные с сервера, но отсутствует подключение к интернету и другие ошибки необходимо как-то обрабатывать. В Swift есть механизм, для которого есть 3 шага:

 1. Объявить все ошибки, которые могут возникнуть во время работы приложения
 2. Указать в функции, что она может выкинуть одну и более ошибок. В остальном тело функции работает как обычно и в особые моменты она может вернуть ошибку
 3. Обработать вызов функции и ошибки, которые могут возникнуть во время работы

 Начнём по порядку. Возьмём обработку пользовательского пароля. Мы хотим, чтобы он был безопасный. Но могут возникнуть такие проблемы как слишком короткий пароль или он состоит из предсказуемого набора символов (1111 или 12345 и т.п.).

 Объявим наши ошибки в перечислении:
 */

enum PasswordError: Error {
	case tooShort
	case obvious
}

/*:
 На первый взгляд `PasswordError` - обычное перечисление с двумя вариантами значений: пароль слишком короткий или пароль слишком очевидный. Но главным отличием является объявления типа для нашего перечисление с помощью уже знакомой конструкции с двоеточием и самим типом, в данном случае `Error`. Почему мы делаем так будет объяснено чуть позже. Больше ничего необычного здесь нет

 Перейдём к нашей функции проверки пароля
 */

func checkPassword(_ password: String) throws -> String {
	if password.count < 5 { throw PasswordError.tooShort }
	if password == "12345" { throw PasswordError.obvious }

	if password.count < 8 {
		return "Слабый"
	} else if password.count < 10 {
		return "Средний"
	}

	return "Сильный"
}

/*:
 В данной функции нам интересны строки `throws -> String` и `throw PasswordError.<ошибка>`.

 Для того чтобы объявить всем, что функция может "выкинуть" ошибку, мы пишем `throws` сразу после скобок. Если функция что-то возвращает, тогда объявление типа возвращаемого значения ставится сразу после

 В моменты, когда на надо "выкинуть" ошибку, мы пишем `throw <ошибка>`. В нашем примере мы проверяем пароль на длину, для определения его безопасности. Но если пароль состоит из 4 символов или меньше, тогда функция ругается и выкидывает ошибку `PasswordError.tooShort`. Так в месте вызова мы будем знать точно, что пошло не так и сможем корректно обработать. Просто написать `throw` нельзя, так как мы должны знать, что за ошибка вызвала ранний возврат из функции, так как поведение схоже с `return`, за тем исключением, что мы вернём ошибку, а не значение

 Если же пароль больше 5 символов и он не похож на мой пароль от багажа, тогда будут выполнены обычные проверки и из функции вернётся настоящее значение

 - Note:
 Пара заметок по коду функции. Допускается написание формата `if password.count < 5 { throw PasswordError.tooShort }`. Если условие короткое и тело условия составляет одну строку, то для сохранения места можно писать так

	Проверки безопасности пароля состоят из двух условий и общего возврата в конце. Поскольку больше никаких действий в функции мы не будем производить, то последний `else` можно не писать для чистоты кода. Альтернативный способ написания может выглядеть так:

		if password.count < 8 {
			return "Слабый"
		} else if password.count < 10 {
			return "Средний"
		} else {
			return "Сильный"
		}

 Всё остаётся сделать теперь, это вызвать функцию и обработать ошибки. Делается это в три этапа в блоке `do { … } catch { … }`:

 1. Начать специальный блок для выполнения функций с потенциальными ошибками `do { … }`
 2. "Попытаться" вызвать все нужные функции с ключевым словом `try`
 3. Поймать ошибки с помощью блока `catch`
 */

func printPasswordInfo(for passwordStrength: String) {
	print("Ваш пароль: \(passwordStrength)")
}

do {
	let strongPasswordResult = try checkPassword("strong_passw0rd")
	printPasswordInfo(for: strongPasswordResult)
	let weakPasswordResult = try checkPassword("1111")
	printPasswordInfo(for: weakPasswordResult)
} catch {
	print("Произошла ошибка при попытке проверить пароль")
}

/*:
 Обратите внимание на результат в консоли. Там присутствует две строки: _Ваш пароль: Сильный_ и _Произошла ошибка при попытке проверить пароль_. Это неспроста. Пометка вызова функции с помощью `try` означает, что данная строка "опасна" и может выдать ошибку. Если ошибка действительно произошла, тогда произойдёт немедленный переход к блоку `catch` вне зависимости от того, что ещё осталось после строки с ошибкой

 Но возникает вопрос: а зачем мы создавали разные ошибки, если сообщение всё равно выводиться одно и тоже для любой ошибки? Для того, чтобы обработать конкретную ошибку существует два способа:

 1. Создать для необходимых ошибок отдельные блоки `catch`
 2. В общем блоке `catch` Xcode передаёт константу `error` (которую мы переименуем в примере, так как такая возможностью существует)
 */

do {
	let weekPasswordResult = try checkPassword("12345")
} catch PasswordError.obvious { // 1. Можно для каждой ошибки вывести отдельный блок `catch`
	print("Это мой пароль от багажа! Используй другой")
} catch let passwordError {
	print("Произошла ошибка при попытке проверить пароль: \(passwordError.localizedDescription)")
}

/*:
 - Note:
 Обратите внимание на интерполяцию в строке 124. Для большинства ошибок, которые пишет Apple, существуют локализированные описания. Для этого используется специальный тип `LocalizedError` в которой и прописывается отдельная переменная `localizedDescription`. В будущем будет рассмотрен ещё один вариант обработки ошибок и как создать своё описание для созданных ошибок
 */
//: [День 7](@previous) | [Содержание](Home) | [Контрольная точка 4](@next)
