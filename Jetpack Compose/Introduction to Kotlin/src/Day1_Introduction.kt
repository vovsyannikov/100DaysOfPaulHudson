/**
 * # День 1: Введение в Kotlin
 */
fun main() {
    /**
     * В Kotlin, как и во многих языках, для работы с данными, их необходимо определить в переменные.
     *
     * Для решения данной задачи имеются два типа переменных: изменяемые и фиксированные
     *
     * - *Фиксированные* не могут быть изменены, после первого присвоения значения
     * - *Изменяемы* могут поменять значение в том случае, если совпадает тип
     *
     * Чтобы задать фиксированную переменную, так же известные как константа, необходимо:
     * - Написать ключевое слово `val`
     * - Название переменной. В разных случаях следует использовать разный стиль, но в большинстве случаев это `camelCase`
     * так же известный как верблюжий шрифт.
     * В нём первое слово переменной начинается с маленькой буквы, а каждое последующее слово идёт без пробелов с большой буквы
     * - Знак равно, означающий присвоение значения справа в переменную слева
     * - Само значение
     */

    val kotlinGreeting = "Hello, World!"

//    greeting = "Hello, Kotlin" // Ошибка компиляции, так как `kotlinGreeting` объявлена как фиксированная переменная

    /**
     * Объявление переменной отличается от константы ключевым словом `var` вначале.
     * В остальном шаги схожи с декларацией (объявлением) константы
     */

    var name = "John"
    name = "Иван"

    /**
     * Kotlin относится к строго типизированным языкам.
     * Это означает, что на момент создания переменной она обязана знать свой тип данных
     */

    var number = 9

//    number = "18" // Ошибка компиляции, так как мы пытаемся присвоить в числовую переменную, строковые значения

    number = 42

    /**
     * ## Как создавать строки
     *
     * Для задания строк стоит записывать любой текст, заключённый в двойные кавычки `""`. Содержание может быть любым
     */

    val actor = "Дензел Вашингтон"
    val filename = "image.jpg"
    val result = "⭐️ Победа! ⭐️"

    /**
     * - Note:
     * Если в тексте необходимо прописать двойные кавычки или любой другой символ, который имеет особый смысл для компилятора,
     * перед ним необходимо поставить `\`
     */

    val quote = "Then he tapped a sign saying \"Believe\" and walked away"

    /**
     * Так же существует потребность сделать переносы в тексте. Для этого есть два способа:
     * - Использовать тройку двойных кавычек вместо одних.
     * В таком случае текст можно натурально переносить по строкам, а так же вставлять табуляторы
     */

    val movie1 = """
Один день из
	жизни
разработчика Kotlin
"""
    println(movie1)

    /**
     * - В тексте вставлять особые символы: `\n` для переноса строк и `\t` для табуляторов
     */

    val movie2 = "Один день из\n\tжизни\nразработчика Apple"
    println(movie2)

    /**
     * У всех объектов в Kotlin существует дополнительный функционал, который доступен через точку
     *
     * Например: можно получить количество символов в строке с помощью метода `count()`
     * Это значение можно как присвоить другой переменной или использовать отдельно, как например в функции `println`
     */
    val nameLength = actor.count()
    println(nameLength)
    println(actor.count())

    /**
     * Можно вывести строку заглавными или строчными буквами через методы `uppercase()` и `lowercase()` соответственно
     */

    result.uppercase()

    /**
     * Можно узнать, начинается или заканчивается слово на определённых символах с помощью методов `startsWith` и `endsWith`
     * Для этого внутри скобок надо передать значение, которое мы хотим проверить
     */

    println(filename.endsWith("jpg"))

    /**
     * ## Как хранить целые числа
     *
     * Как и в случае со строковыми значениями мы можем создать целочисленную переменную или константу.
     * Важно отметить, что значение должно быть написано без кавычек, так как это символ начала строки
     */

    val score = 100

    /**
     * Стоит отметить очень занятный способ для улучшения читаемости больших чисел.
     * Мы не можем использовать пробелы или запятые для разделения, но вполне разрешено использовать нижнее подчёркивание
     * Можно вставить несколько символов и в разные места, однако такой способ выглядит не очень прилично
     */

    val badBig = 1000000000
    val normalBig = 1_000_000_000
    val reallyBadBig = 1_000__0___0____0_00________0

    /**
     * Для чисел есть стандартный набор арифметических операций сложения, вычитания, умножения и сложения
     */

    val higherScore = score + 10
    val lowerScore = score - 2
    val doubledScore = score * 2
    val halvedScore = score / 2
    val squaredScore = score * score

    /**
     * Для увеличения или уменьшения значения есть несколько способов
     */

    var counter = 0
    counter = counter + 1
    counter += 1
    counter++

    println(counter)
    /**
     * Все операции выше делают одну и ту же операцию увеличения `counter` на 1
     *
     * Такой же аналог, как на строке 142 существует и для операции вычитания.
     * Они работают только на 1, в отличие от варианта на строке 141
     * (который является предпочтительным и основная среда разработки будет ругаться на иной подход),
     * где мы можем указать значение, на которое стоит увеличивать значение
     *
     * Подобные строке 141 операции доступны и для остальных арифметических операций
     */

    counter *= 5
    counter -= 9
    counter /= 2
    println(counter)

    /**
     * Целочисленные значения не единственные числа, с которыми мы можем работать.
     * Подробней все они будут рассмотрены позже, но для начала посмотрим на два основных типа данных `Float` и `Double`
     *
     * Первый - это обычное дробное числа, а второе - с двойной точностью (оно может хранить больше чисел после запятой)
     *
     * Для обозначения дробного числа, его целая часть и десятичная пишутся через точку.
     * Чтобы обозначить, что число с меньшей точностью (а так же меньшими затратами по памяти), в конце прописывается буква `f`
     */

    val doubleValue = 3.147
    val floatValue = 3.147f

    /**
     * Для дробных чисел так же доступны все арифметические операции, что и для целых
     *
     * Ради интереса, почему нам нужны два типа для дробных чисел, вот пример,
     * который наглядно показывает всю сложность работы с такими значениями:
     */

    val problematicValue = 0.1 + 0.2
    println(problematicValue)
}